# -*- coding: utf-8 -*-
r"""
The Topology of Real Parabolic Arrangements
============================================

OVERVIEW
--------

This module implements the computational framework for studying the
**topology of complements of parabolic arrangements** associated to finite
Coxeter groups, as developed in:

    **J. Cantarero and J. L. León-Medina**,
    *"The Topology of Real Parabolic Arrangements"*.

It provides algorithms for computing:

1. **Cellular (co)homology** of the complement `\mathscr{M}_{\mathscr{A}}`
   via the restricted permutahedral complex `K_{\mathscr{A}}`.
2. **Cup product** (cohomology ring structure) induced by a diagonal
   approximation transported from the classical Serre diagonal on cubes
   to the permutahedral setting.
3. **Fundamental groups** via Bridson--Haefliger complexes of groups
   (Ch.\,III.\(\mathcal{C}\) of [BH99]), yielding explicit presentations
   obtained by deleting selected Coxeter relations.
4. **Euler characteristics** via orbit-weighted formulas for invariant
   arrangements.
5. **Geometric asphericity** criteria (`K(\pi,1)` property) expressed in
   terms of the associated Coxeter graph (triangle-free criterion).


MATHEMATICAL BACKGROUND
-----------------------

Let `(W, S)` be a finite Coxeter system of rank `n` with simple
reflections `S = \{s_1, \ldots, s_n\}`.  For `I \subseteq S`, the
subgroup `W_I \le W` generated by `I` is a **standard parabolic
subgroup**.  A **parabolic coset** is a left coset `wW_I` with
`w \in W`, `I \subseteq S`.

The Coxeter group `W` has two canonical dual geometric models:

- The **Coxeter complex** `\mathcal{C}(W)`: a spherical simplicial
  decomposition of `S^{n-1}` whose faces are in bijection with
  parabolic cosets `wW_I` (`I \subsetneq S`).
- The **Coxeter permutahedron** `\mathrm{Perm}(W)`: a zonotopal
  polytope dual to `\mathcal{C}(W)`.

A **parabolic arrangement** `\mathscr{A}` is a collection of
parabolic cosets forming a **filter** in the inclusion poset of
parabolic cosets (equivalently, an order ideal in the face poset of
`\mathcal{C}(W)`).  The complement is:

.. MATH::

    \mathscr{M}_{\mathscr{A}}
    = |\mathcal{C}(W)| \setminus |\mathscr{A}|.

By Björner--Ziegler duality [BZ92], the complement is homotopy
equivalent to the **restricted permutahedral complex**:

.. MATH::

    K_{\mathscr{A}} \subset \mathrm{Perm}(W),

the subcomplex of `\mathrm{Perm}(W)` consisting of all dual cells
`D(\alpha)` such that the corresponding face `\alpha` of the Coxeter
complex does not lie in `\mathscr{A}`.  This is the central result:

    **Theorem** (General Equivalence):
    `\mathscr{M}_{\mathscr{A}} \simeq |K_{\mathscr{A}}|`.


CONNECTIVITY
------------

If the arrangement has minimal rank `c \ge 3` (i.e. `|I| \ge c` for
all `wW_I \in \mathscr{A}`), then the complement is `(c-2)`-connected:

.. MATH::

    \pi_i(\mathscr{M}_{\mathscr{A}}) = 0 \quad
    \text{for all } i \le c - 2,

and the first non-vanishing homotopy group occurs in dimension `c - 1`.
In particular, non-trivial fundamental groups occur only in the presence
of rank-2 parabolic subgroups.


CELLULAR CHAIN COMPLEX AND BOUNDARY OPERATOR
---------------------------------------------

Cells of `K_{\mathscr{A}}` are indexed by parabolic cosets `wW_I` with
grading:

.. MATH::

    \deg(wW_I) = |I|.

Fix a total ordering `S = \{s_1, \ldots, s_n\}` with `s_1 < \cdots < s_n`.
The cellular boundary operator (Definition 5 of the paper) is:

.. MATH::

    \partial(wW_I)
    = \sum_{s \in I} (-1)^{o_I(s)}
      \sum_{g \in W_I^{I \setminus \{s\}}} (-1)^{\ell(g)}\, wg\, W_{I \setminus \{s\}},

where `o_I(s) = |\{t \in I \mid t < s\}|` and `W_I^{I \setminus \{s\}}`
denotes the set of minimal-length left coset representatives of
`W_{I \setminus \{s\}}` in `W_I`.

This formula, consistent with the combinatorial structure of the
permutahedron [Milgram66, Eq. 4.3] and the alternation operator of
Davis [Davis08, Eq. 8.1], encodes the signed incidence numbers of
the Coxeter permutahedron.

The (co)homology of the complement is:

.. MATH::

    H_k(\mathscr{M}_{\mathscr{A}};\mathbb{Z})
    \cong H_k(C_\bullet(K_{\mathscr{A}})),
    \qquad
    H^k(\mathscr{M}_{\mathscr{A}};\mathbb{Z})
    \cong H^k(C^\bullet(K_{\mathscr{A}})).


CELLULAR DIAGONAL AND CUP PRODUCT
----------------------------------

The Coxeter permutahedron is a root zonotope:

.. MATH::

    \mathrm{Perm}(W)
    = \sum_{\alpha \in \Phi^+}
      \bigl[-\tfrac{1}{2}\alpha, \tfrac{1}{2}\alpha\bigr].

Each parabolic cell `wW_I` carries a face lattice canonically
isomorphic to that of the `|I|`-cube.  This yields a **general
zonotopal diagonal** via pushforward of the Serre diagonal:

.. MATH::

    \Delta_Z(wW_I)
    := (p_{I\#} \otimes p_{I\#})
       \bigl(\Delta_{\mathrm{Serre}}(E_I)\bigr),

where `p_I: \square^{\Phi_I^+} \to wW_I` is the canonical projection.

**Cubical reduction** (Theorem: Cubical Diagonal Reduction):
A parabolic cell `wW_I` is called **strictly commutative** if
`m_{ij} = 2` for all pairs `s_i, s_j \in I`.  In this case
`\Phi_I^+ = \{\alpha_s \mid s \in I\}`, the projection `p_I` is
a cellular isomorphism, and the diagonal reduces exactly to:

.. MATH::

    \Delta_Z(wW_I)
    = \sum_{J \sqcup K = I}
      \varepsilon(J,K)\,(wW_J) \otimes (w\,w_{0,J}\,W_K),

where `w_{0,J}` is the longest element in `W_J` and
`\varepsilon(J,K) = (-1)^{\mathrm{inv}(J,K)}` is the shuffle sign.

Dualizing yields the cup product on cochains:

.. MATH::

    (u \smile v)(wW_I)
    = \sum_{\substack{J \sqcup K = I \\ |J|=p,\,|K|=q}}
      \varepsilon(J,K)\, u(wW_J)\, v(w\,w_{0,J}\,W_K).

.. NOTE::

    The cubical formula above applies **exactly** when `wW_I` is strictly
    commutative.  For non-commutative cells (rank-2 zonotopes with
    `m_{st} \ge 3`), the general zonotopal diagonal must be used.  This
    module implements the cubical fast-path for commutative cells and
    explicit rhombus decompositions for rank-2 hexagonal (`m=3`) and
    octagonal (`m=4`) cells.  Higher non-commutative zonotopes and
    rank `\ge 3` non-commutative cells (Saneblidze--Umble diagonal)
    are not yet implemented.


DGA STRUCTURE
-------------

The cup product makes `(C^\bullet(K_{\mathscr{A}}), \delta)` into a
**differential graded algebra** (DGA):

- The product `\smile` is **associative** (strictly).
- The differential satisfies the **graded Leibniz rule**:

.. MATH::

    \delta(u \smile v)
    = (\delta u) \smile v
    + (-1)^{\deg u}\, u \smile (\delta v).

Consequently, the induced product on cohomology coincides with the
singular cup product on `H^*(\mathscr{M}_{\mathscr{A}};\mathbb{Z})`.


FUNDAMENTAL GROUPS VIA ORBIFOLD EXTENSIONS
------------------------------------------

When the arrangement is `H`-invariant for a subgroup `H \le W`, the
cellular action of `H` on `K_{\mathscr{A}}` induces a **complex of
groups** structure on the quotient scwol `\mathcal{Y} = H \backslash
\mathcal{X}_{\mathscr{A}}` (Bridson--Haefliger, Ch. III.\(\mathcal{C}\)).

The **orbifold fundamental group** `\Gamma_{\mathscr{A}}` fits into a
short exact sequence:

.. MATH::

    1 \longrightarrow \pi_1(K_{\mathscr{A}}, x_0)
      \longrightarrow \Gamma_{\mathscr{A}}
      \xrightarrow{\;\rho\;} H
      \longrightarrow 1.

In the `W`-invariant case, `\Gamma_{\mathscr{A}}` admits a **modified
Coxeter presentation** (Theorem: Presentation of the Orbifold Group):

.. MATH::

    \Gamma_{\mathscr{A}}
    = \Big\langle S \;\Big|\;
      s^2 = 1,\;
      (st)^{m'_{st}} = 1 \text{ whenever } m'_{st} < \infty
      \Big\rangle,

where `m'_{st} = m_{st}` if the rank-2 stratum `\sigma_{st}` is
retained and `m'_{st} = \infty` if it is excised.  That is, excising the
`W`-orbit of a rank-2 stratum corresponds to deleting the associated
Coxeter relation.

This module computes `\pi_1(K_{\mathscr{A}})` via three routes:

- **W-route** (modified Coxeter extension):
  Valid when the arrangement is `W`-invariant and all rank-1 strata
  are retained.  Uses the exact sequence
  `1 \to \pi_1 \to \Gamma_{\mathscr{A}} \to W \to 1`.

- **B&H full route**:
  Bridson--Haefliger complex-of-groups computation.  Valid when the
  arrangement is `H`-invariant for a subgroup `H \le W` and all
  rank-1 strata survive.

- **CW 2-skeleton route**:
  Direct computation from the 2-skeleton of `K_{\mathscr{A}}`.
  Always valid; robust fallback for non-invariant arrangements.


GEOMETRIC ASPHERICITY
---------------------

When `K_{\mathscr{A}}` inherits a piecewise Euclidean (Moussong) metric,
the **Flag Criterion** (Theorem) provides a sufficient condition for
asphericity: if every vertex link `L_w(K_{\mathscr{A}})` is a **metric
flag complex**, then every connected component of
`\mathscr{M}_{\mathscr{A}}` is a `K(\pi,1)`.

For `W`-invariant arrangements that remove all parabolic cosets of rank
`\ge 3`, the **Triangle-Free Criterion** (Corollary) gives a necessary
and sufficient condition:

    `\mathscr{M}_{\mathscr{A}}` is a `K(\pi,1)` if and only if the
    graph `\Gamma_{\mathscr{A}}` (vertices `S`, edges for retained
    rank-2 strata) is **triangle-free**.


EULER CHARACTERISTIC
--------------------

For `W`-invariant arrangements, the Euler characteristic admits a
closed orbit-weighted formula (Corollary):

.. MATH::

    \chi(\mathscr{M}_{\mathscr{A}})
    = |W| \sum_{J \in \mathcal{T}_{\mathscr{A}}}
      \frac{(-1)^{|J|}}{|W_J|},

where `\mathcal{T}_{\mathscr{A}}` is the collection of subset types
retained in the complex.


REFERENCES
----------

- [CL] J. Cantarero and J. L. León-Medina,
  "The Topology of Real Parabolic Arrangements".
- [BZ92] A. Björner and G. Ziegler,
  "Combinatorial stratification of complex arrangements",
  J. Amer. Math. Soc. 5 (1992), 105--149.
- [Davis08] M. W. Davis,
  *The Geometry and Topology of Coxeter Groups*,
  Princeton Univ. Press, 2008.
- [BH99] M. R. Bridson and A. Haefliger,
  *Metric Spaces of Non-Positive Curvature*,
  Springer, 1999.  Chapter III.\(\mathcal{C}\).
- [Milgram66] R. J. Milgram,
  "The homology of symmetric products",
  Trans. Amer. Math. Soc. 138 (1969), 251–265.
- [BSW11] H. Barcelo, C. Severs, and J. White,
  "k-parabolic subspace arrangements",
  Trans. Amer. Math. Soc. 363 (2011), 6063--6083.
- [Khovanov96] M. Khovanov,
  "Real `K(\pi,1)` arrangements from finite root systems",
  Math. Res. Lett. 3 (1996), no. 2, 261--274.

NOTES
-----

- This code targets **real** parabolic arrangements (Davis complex /
  Coxeter permutahedron), **not** complexified arrangements (Salvetti
  complex).  Generators satisfy `s^2 = 1` (Coxeter relations), not
  braid-type relations.  The 1-skeleton of `K_{\mathscr{A}}` is the
  Cayley graph of `W` with unoriented edges.
- The current implementation uses SageMath's ``RootSystem`` and requires
  finite **Weyl groups** (crystallographic Coxeter groups).  The
  mathematical theory in [CL] applies to all finite Coxeter systems
  (including `H_3`, `H_4`, `I_2(m)`), but non-crystallographic types
  are not yet supported by the code.
- Portions of the implementation were developed with AI assistance and
  have been rigorously verified against the mathematical theory.

VERSION: 3.0 (March 2026)
"""


from sage.all import (
    RootSystem, Integer, ZZ, GF, QQ,
    cached_method, cached_function
)
# Aliased imports to avoid namespace collisions in notebooks
from sage.all import Matrix as SageMatrix
from sage.all import vector as SageVector
from sage.graphs.graph import Graph
from sage.graphs.digraph import DiGraph
from sage.groups.free_group import FreeGroup
from sage.rings.finite_rings.finite_field_base import FiniteField
from collections import OrderedDict, defaultdict, deque
from itertools import combinations
import itertools


# ==============================================================================
# Main Class
# ==============================================================================

class ParabolicArrangement(object):
    r"""
    Topology of a Parabolic Arrangement Complement.

    This class computes the cellular cochain complex
    `C^\bullet(K_{\mathscr{A}}, R)`, cohomology ring
    `H^*(\mathscr{M}_{\mathscr{A}};R)`, and fundamental group
    `\pi_1(\mathscr{M}_{\mathscr{A}})` of the complement of a
    parabolic arrangement associated to a finite Coxeter system `(W, S)`.

    The complement `\mathscr{M}_{\mathscr{A}}` is homotopy equivalent
    to the **restricted permutahedral complex** `K_{\mathscr{A}}`, a
    CW subcomplex of the Coxeter permutahedron `\mathrm{Perm}(W)`
    whose cells are indexed by parabolic cosets `wW_I` not in the
    arrangement [CL, Theorem 1].

    COHOMOLOGY ATTRIBUTES:

    - ``W`` -- The ambient Coxeter (Weyl) group
    - ``S`` -- Sorted list of simple reflection indices
    - ``cells`` -- List of retained cells in canonical form `(w, J)`,
      where `w` is the minimal-length coset representative in `wW_J`
    - ``by_grade`` -- Dictionary `k \mapsto [\text{cells of degree } k]`
      (degree `k = |J|`)
    - ``map_cell_to_idx`` -- Fast lookup: `(k, cell) \mapsto \text{index}`
    - ``max_grade`` -- Maximum cell dimension in `K_{\mathscr{A}}`

    FUNDAMENTAL GROUP ATTRIBUTES (available after :meth:`init_pi1`):

    - ``H`` -- Subgroup of `W` used for orbifold quotient
    - ``H_elements`` -- Elements of `H` coerced to `W`
    - ``orbits`` -- Cell-to-orbit-id map under `H`-action
    - ``reps`` -- Orbit-id-to-representative-cell map
    - ``stabilizers`` -- Orbit-id-to-stabilizer map
      (`\mathrm{Stab}_H(\widetilde{\sigma}) = H \cap wW_Iw^{-1}`)
    - ``Y`` -- Quotient scwol `\mathcal{Y} = H \backslash
      \mathcal{X}_{\mathscr{A}}` as DiGraph

    INPUT:

    - ``W`` -- A Weyl group (from ``RootSystem(...).ambient_space().weyl_group()``)
    - ``Plist`` -- List of all parabolic cosets (face poset of the Coxeter
      complex, obtained via ``W.milnor_fiber_poset()``)
    - ``Delta`` -- Subset of ``Plist`` defining the excluded arrangement
      `\mathscr{A}`, i.e. the parabolic cosets to be removed
    - ``max_cache_size`` -- (default: 100000) Maximum entries in LRU cache

    .. NOTE::

        The mathematical framework in [CL] applies to all finite Coxeter
        systems (including non-crystallographic types `H_3`, `H_4`,
        `I_2(m)`).  This implementation currently requires crystallographic
        (Weyl) groups due to SageMath's ``RootSystem`` interface.

    EXAMPLES::

        sage: from parabolic_arrangement import *
        sage: W, Plist, _ = build_W_P('A', 3)
        sage: Delta = ideal_k_parabolic(W, Plist, k=3)
        sage: arr = ParabolicArrangement(W, Plist, Delta)
        sage: H1 = arr.cohomology_basis(1, ring=GF(2))
        sage: print(f"dim H^1 = {len(H1)}")
    """

    def __init__(self, W, Plist, Delta, max_cache_size=100000):
        r"""
        Initialize the restricted permutahedral complex `K_{\mathscr{A}}`.

        Builds the cell index from ``Plist`` by removing cells in ``Delta``
        (the arrangement).  Each cell `(w, J)` is stored in canonical form:
        `J` sorted, `w` the minimal-length representative in the coset
        `wW_J`.

        INPUT:

        - ``W`` -- Weyl group (finite Coxeter group)
        - ``Plist`` -- List of all parabolic cosets (face poset of
          `\mathcal{C}(W)`)
        - ``Delta`` -- Excluded cells defining the arrangement
          `\mathscr{A}` (filter in the parabolic coset poset)
        - ``max_cache_size`` -- (default: 100000) LRU cache size for
          minimal-length coset representative computations

        TESTS::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: arr = ParabolicArrangement(W, Plist, set())
            sage: len(arr.cells) > 0
            True
            sage: arr.max_grade == 2
            True
        """
        self.W = W
        self._max_cache_size = max_cache_size

        # Cache simple reflections (used extensively throughout)
        self._sref = self.W.simple_reflections()
        self.S = sorted(self._sref.keys())

        # Initialize caches (fresh for each instance)
        self._w0_cache = {}  # longest elements w_{0,J}
        self._coset_reps_cache = {}  # (K_tuple, s_idx) -> list of (g, sign)
        self._structure_cache = OrderedDict()  # LRU-style structure cache
        self._max_structure_cache_size = 50
        self._min_cache = OrderedDict()  # Manual LRU cache for minimization
        self._max_cache_size = max_cache_size

        # Step 1: Canonicalize exclusion set
        delta_clean = set()
        if Delta:
            for c in Delta:
                if self._is_valid_cell(c):
                    delta_clean.add(self._canonize(c))

        # Step 2: Filter and canonicalize cells from Plist
        self.cells = []
        seen = set()

        for c in Plist:
            if not self._is_valid_cell(c):
                continue

            canon_c = self._canonize(c)

            if canon_c in delta_clean or canon_c in seen:
                continue

            self.cells.append(canon_c)
            seen.add(canon_c)

        # Step 3: Index cells by grading (degree k = |J|)
        self.by_grade = {}
        self.map_cell_to_idx = {}

        for c in self.cells:
            k = len(c[1])
            self.by_grade.setdefault(k, []).append(c)

        # Step 4: Sort for reproducibility and build index
        for k in self.by_grade:
            self.by_grade[k].sort(key=lambda x: (str(x[0]), x[1]))
            for idx, c in enumerate(self.by_grade[k]):
                self.map_cell_to_idx[(k, c)] = idx

        self.max_grade = max(self.by_grade.keys()) if self.by_grade else 0

        # Pi1 state (initialized by init_pi1)
        self._pi1_initialized = False

    # ==========================================================================
    # Utility Methods
    # ==========================================================================

    @staticmethod
    def _is_valid_cell(c):
        r"""
        Check if `c` is a valid cell: tuple `(w, J)` where `J` is a tuple.
        """
        return (isinstance(c, tuple) and
                len(c) == 2 and
                isinstance(c[1], (tuple, list)))

    @staticmethod
    def _is_char2(ring):
        r"""
        Robust test for characteristic 2 rings.
        """
        try:
            return ring.characteristic() == 2
        except (AttributeError, NotImplementedError):
            return False

    @staticmethod
    def _as_vector(ring, x):
        r"""
        Coerce `x` to a Sage vector over `ring`.
        """
        if hasattr(x, "parent"):
            return x
        return SageVector(ring, x)

    def clear_caches(self):
        r"""
        Clear all internal caches to free memory.
        """
        self._w0_cache.clear()
        self._coset_reps_cache.clear()
        self._structure_cache.clear()
        self._min_cache.clear()

    def cache_info(self):
        r"""
        Return cache statistics.
        """
        return {
            'minimize_size': len(self._min_cache),
            'minimize_maxsize': self._max_cache_size,
            'w0_cache_size': len(self._w0_cache),
            'coset_reps_cache_size': len(self._coset_reps_cache),
            'structure_cache_size': len(self._structure_cache)
        }

    # ==========================================================================
    # Coxeter Group Computations
    # ==========================================================================

    def _canonize(self, c):
        r"""
        Return canonical form of cell `c = (w, J)`.

        Canonical form: `J` sorted tuple, `w` replaced by the
        minimal-length representative in the coset `wW_J` (i.e.
        the unique element with no right descents in `J`).
        """
        w, J = c
        J_tuple = tuple(sorted(J))
        w_min = self._minimize_in_coset(w, J_tuple)
        return (w_min, J_tuple)

    def _minimize_in_coset(self, w, J_tuple):
        r"""
        Compute minimal-length representative in coset `wW_J` with LRU cache.

        Uses ``has_descent`` instead of ``length()`` comparison for ~17x speedup
        on matrix-backed Weyl group elements.
        """
        key = (w, J_tuple)

        if key in self._min_cache:
            self._min_cache.move_to_end(key)
            return self._min_cache[key]

        current = w
        changed = True

        while changed:
            changed = False
            for s_idx in J_tuple:
                if current.has_descent(s_idx, side='right'):
                    current = current * self._sref[s_idx]
                    changed = True

        if len(self._min_cache) >= self._max_cache_size:
            self._min_cache.popitem(last=False)

        self._min_cache[key] = current
        return current

    def _get_w0_J(self, J_tuple):
        r"""
        Return the longest element `w_{0,J}` in the parabolic subgroup `W_J`.

        The element `w_{0,J}` plays a central role in the cubical diagonal
        formula [CL, Theorem: Cubical Diagonal Reduction]: it encodes the
        geometric involution that carries the basepoint `w` (the minimal
        vertex of `wW_I` in weak order) to the opposite vertex `ww_{0,J}`
        along the `J`-directions, identifying the starting point of the
        back face `ww_{0,J}W_K`.
        """
        if J_tuple in self._w0_cache:
            return self._w0_cache[J_tuple]

        if not J_tuple:
            res = self.W.one()
        else:
            try:
                res = self.W.long_element(list(J_tuple))
            except (AttributeError, TypeError):
                sub = self.W.reflection_subgroup(list(J_tuple))
                res = self.W(sub.long_element())

        self._w0_cache[J_tuple] = res
        return res

    def _is_commutative(self, I_tuple):
        r"""
        Check if parabolic subgroup `W_I` is **strictly commutative**.

        A parabolic cell `wW_I` is strictly commutative if `m_{ij} = 2`
        for all pairs of distinct generators `s_i, s_j \in I`
        [CL, Definition before Lemma: Cube].  In this case the root
        zonotope `wW_I` is isomorphic to a cube `\square^{|I|}`, and
        the cubical (Serre) diagonal formula applies exactly.
        """
        if len(I_tuple) <= 1:
            return True
        cox = self.W.coxeter_matrix()
        for i in range(len(I_tuple)):
            for j in range(i + 1, len(I_tuple)):
                if cox[I_tuple[i], I_tuple[j]] != 2:
                    return False
        return True

    def _minimal_coset_reps(self, K_tuple, s_idx):
        r"""
        Compute minimal-length left coset representatives
        `W_K^{K \setminus \{s\}}` of `W_{K \setminus \{s\}}` in `W_K`.

        These representatives are needed for the boundary operator
        [CL, Definition 5].  An element `g \in W_K` is a minimal
        representative if it has no right descent in `K \setminus \{s\}`.

        Results are cached by ``(K_tuple, s_idx)`` since they depend only
        on the parabolic subgroup structure.

        OUTPUT:

        List of pairs ``(g, sign)`` where ``sign = (-1)^{\ell(g)}``.
        """
        cache_key = (K_tuple, s_idx)
        if cache_key in self._coset_reps_cache:
            return self._coset_reps_cache[cache_key]

        K_list = list(K_tuple)
        J_list = [x for x in K_list if x != s_idx]

        generators_K = [self._sref[k] for k in K_list]
        identity = self.W.one()
        W_K_elements = {identity}
        frontier = [identity]

        while frontier:
            new_frontier = []
            for g in frontier:
                for gen in generators_K:
                    h = g * gen
                    if h not in W_K_elements:
                        W_K_elements.add(h)
                        new_frontier.append(h)
            frontier = new_frontier

        reps = []
        for g in W_K_elements:
            is_min = True
            for t in J_list:
                if g.has_descent(t, side='right'):
                    is_min = False
                    break

            if is_min:
                g_len = g.length()
                sign = 1 if (g_len % 2 == 0) else -1
                reps.append((g, sign))

        reps.sort(key=lambda pair: pair[0].length())
        self._coset_reps_cache[cache_key] = reps
        return reps

    # ==========================================================================
    # Differential (Coboundary Operator)
    # ==========================================================================

    def coboundary_matrix(self, k, ring=ZZ):
        r"""
        Cellular coboundary matrix `\delta^k: C^k \to C^{k+1}`.

        Implements the dual of the boundary operator from
        [CL, Definition 5].  For each `(k+1)`-cell `(w, K)` and each
        `s \in K`, let `J = K \setminus \{s\}` and
        `W_K^J` be the set of minimal-length left coset representatives
        of `W_J` in `W_K`.  The boundary is:

        .. MATH::

            \partial(wW_K)
            = \sum_{s \in K} (-1)^{o_K(s)}
              \sum_{g \in W_K^J} (-1)^{\ell(g)}\, wg\, W_J.

        The coboundary matrix `\delta^k` is the transpose of the matrix
        representing `\partial` restricted to `(k+1)`-cells mapping to
        `k`-cells.

        INPUT:

        - ``k`` -- non-negative integer (degree)
        - ``ring`` -- (default: ``ZZ``) coefficient ring

        OUTPUT:

        Matrix over ``ring`` of size `\dim C^{k+1} \times \dim C^k`,
        representing the coboundary operator on the cellular cochain complex
        of `K_{\mathscr{A}}`.
        """
        dom = self.by_grade.get(k, [])
        cod = self.by_grade.get(k + 1, [])
        n_dom, n_cod = len(dom), len(cod)

        if n_dom == 0 or n_cod == 0:
            return SageMatrix(ring, n_cod, n_dom)

        M = SageMatrix(ring, n_cod, n_dom)
        dom_map = {c: j for j, c in enumerate(dom)}
        char2 = self._is_char2(ring)

        for i_cod, (w, K) in enumerate(cod):
            K_list = list(K)

            for pos, s_idx in enumerate(K_list):
                J = tuple(K_list[:pos] + K_list[pos + 1:])
                base_sign = 1 if (pos % 2 == 0 or char2) else -1
                reps = self._minimal_coset_reps(K, s_idx)

                for (g, g_sign) in reps:
                    w_face = self._minimize_in_coset(w * g, J)
                    j_domain = dom_map.get((w_face, J))

                    if j_domain is not None:
                        if char2:
                            M[i_cod, j_domain] += ring(1)
                        else:
                            M[i_cod, j_domain] += ring(base_sign * g_sign)

        return M

    # ==========================================================================
    # Cup Product (Zonotopal Diagonal)
    # ==========================================================================

    def precompute_cup_structure(self, dim_u, dim_v, verbose=False):
        r"""
        Precompute the cup product structure at bidegree `(p, q)` using the
        cellular diagonal approximation.

        Uses a **hybrid strategy** that dispatches each cell to the
        appropriate diagonal formula:

        - **Fast-path** (cubical/Serre diagonal): used for **strictly
          commutative** cells `wW_I` where `m_{ij} = 2` for all
          `s_i, s_j \in I` [CL, Theorem: Cubical Diagonal Reduction].
          The diagonal is:

          .. MATH::

              \Delta(wW_I) = \sum_{J \sqcup K = I}
                \varepsilon(J,K)\,(wW_J) \otimes (w\,w_{0,J}\,W_K).

        - **Slow-path** (rank-2 zonotopes): explicit rhombus
          decompositions for non-commutative `2m`-gonal cells.
          Currently supports `m=3` (hexagon, type `A_2`) and
          `m=4` (octagon, type `B_2`).

        - **Fallback**: raises ``NotImplementedError`` for
          non-commutative cells of rank `\ge 3`, which require the
          full Saneblidze--Umble or zonotopal diagonal [CL, eq. (7)].

        INPUT:

        - ``dim_u`` -- degree of the first cochain factor
        - ``dim_v`` -- degree of the second cochain factor
        - ``verbose`` -- (default: ``False``) print diagnostic info

        OUTPUT:

        List of tuples ``(idx_target, idx_front, idx_back, sign)``
        encoding the non-zero contributions to the cup product at
        the target cell.
        """
        dim_tot = dim_u + dim_v
        key = (dim_u, dim_v)

        if key in self._structure_cache:
            return self._structure_cache[key]

        if verbose:
            print(f"--- Precomputing HYBRID geometry for Cup({dim_u}, {dim_v}) ---")

        cells_tot = self.by_grade.get(dim_tot, [])
        structure = []

        for idx_target, (w, I) in enumerate(cells_tot):

            # =================================================================
            # FAST-PATH: Cubical (Serre) diagonal -- all generators commute
            # =================================================================
            if self._is_commutative(I):
                for partition_indices in itertools.combinations(range(len(I)), dim_u):
                    partition_set = set(partition_indices)
                    J_list, K_list = [], []
                    shuffle_inversions = 0
                    k_count = 0

                    for pos in range(len(I)):
                        element = I[pos]
                        if pos in partition_set:
                            J_list.append(element)
                            shuffle_inversions += k_count
                        else:
                            K_list.append(element)
                            k_count += 1

                    J = tuple(J_list)
                    K = tuple(K_list)

                    w_front = self._minimize_in_coset(w, J)
                    idx_front = self.map_cell_to_idx.get((dim_u, (w_front, J)))
                    if idx_front is None:
                        continue

                    w0_J = self._get_w0_J(J)
                    w_shifted = w * w0_J
                    w_back = self._minimize_in_coset(w_shifted, K)
                    idx_back = self.map_cell_to_idx.get((dim_v, (w_back, K)))
                    if idx_back is None:
                        continue

                    sign = -1 if (shuffle_inversions % 2 == 1) else 1
                    structure.append((idx_target, idx_front, idx_back, sign))

            # =================================================================
            # SLOW-PATH: Rank 2 non-commutative zonotope (2m-gon)
            # =================================================================
            elif len(I) == 2:
                s, t = I[0], I[1]
                cox = self.W.coxeter_matrix()
                m = cox[s, t]

                if dim_u == 1 and dim_v == 1:
                    if m == 3:
                        # HEXAGON (A_2): m=3, 6 edges, 3 rhombi
                        s_ref = self._sref[s]
                        t_ref = self._sref[t]

                        rhombi = [
                            (w,           (s,), w * s_ref,                (t,), +1),
                            (w * s_ref,   (t,), w * s_ref * t_ref,       (s,), +1),
                            (w,           (t,), w * t_ref,               (s,), -1),
                        ]

                        for (w_L, J_L, w_R, J_R, rhombus_sign) in rhombi:
                            w_front = self._minimize_in_coset(w_L, J_L)
                            idx_front = self.map_cell_to_idx.get((dim_u, (w_front, J_L)))
                            if idx_front is None:
                                continue
                            w_back = self._minimize_in_coset(w_R, J_R)
                            idx_back = self.map_cell_to_idx.get((dim_v, (w_back, J_R)))
                            if idx_back is None:
                                continue
                            structure.append((idx_target, idx_front, idx_back, rhombus_sign))

                    elif m == 4:
                        # OCTAGON (B_2): m=4, 8 edges, 6 rhombi
                        s_ref = self._sref[s]
                        t_ref = self._sref[t]
                        w_t = w * t_ref
                        w_ts = w_t * s_ref
                        w_tst = w_ts * t_ref

                        rhombi = [
                            (w,              (s,), w * s_ref,                    (t,), +1),
                            (w * s_ref,      (t,), w * s_ref * t_ref,            (s,), +1),
                            (w * s_ref * t_ref, (s,), w * s_ref * t_ref * s_ref, (t,), +1),
                            (w,              (t,), w_t,                           (s,), -1),
                            (w_t,            (s,), w_ts,                          (t,), -1),
                            (w_ts,           (t,), w_tst,                         (s,), -1),
                        ]

                        for (w_L, J_L, w_R, J_R, rhombus_sign) in rhombi:
                            w_front = self._minimize_in_coset(w_L, J_L)
                            idx_front = self.map_cell_to_idx.get((dim_u, (w_front, J_L)))
                            if idx_front is None:
                                continue
                            w_back = self._minimize_in_coset(w_R, J_R)
                            idx_back = self.map_cell_to_idx.get((dim_v, (w_back, J_R)))
                            if idx_back is None:
                                continue
                            structure.append((idx_target, idx_front, idx_back, rhombus_sign))

                    else:
                        raise NotImplementedError(
                            f"Diagonal de MacPherson-Tonks para el {2*m}-gono "
                            f"(m={m}) no implementada. Soportados: m=3 (hexágono), "
                            f"m=4 (octágono)."
                        )

                elif dim_u == 0 or dim_v == 0:
                    if dim_u == 0 and dim_v == 2:
                        w_front = self._minimize_in_coset(w, ())
                        idx_front = self.map_cell_to_idx.get((0, (w_front, ())))
                        idx_back = self.map_cell_to_idx.get((2, (w, I)))
                        if idx_front is not None and idx_back is not None:
                            structure.append((idx_target, idx_front, idx_back, 1))
                    elif dim_u == 2 and dim_v == 0:
                        idx_front = self.map_cell_to_idx.get((2, (w, I)))
                        w0_I = self._get_w0_J(I)
                        w_back = self._minimize_in_coset(w * w0_I, ())
                        idx_back = self.map_cell_to_idx.get((0, (w_back, ())))
                        if idx_front is not None and idx_back is not None:
                            structure.append((idx_target, idx_front, idx_back, 1))
                else:
                    pass

            # =================================================================
            # FALLBACK: Rank >= 3 non-commutative (Saneblidze-Umble)
            # =================================================================
            else:
                raise NotImplementedError(
                    f"Diagonal Saneblidze-Umble para zonotopos no conmutativos "
                    f"de rango >= 3 no implementada (celda I={I})."
                )

        if len(self._structure_cache) >= self._max_structure_cache_size:
            self._structure_cache.popitem(last=False)
        self._structure_cache[key] = structure

        if verbose:
            print(f"--- Geometry ready. {len(structure)} connections. ---")

        return structure

    def fast_cup_product(self, u, v, dim_u, dim_v, ring=GF(2)):
        r"""
        Cup product `u \smile v` using precomputed diagonal structure.

        Evaluates the cup product formula [CL, Section 7]:

        .. MATH::

            (u \smile v)(wW_I)
            = \sum_{\substack{J \sqcup K = I \\ |J|=p,\,|K|=q}}
              \varepsilon(J,K)\, u(wW_J)\, v(w\,w_{0,J}\,W_K)

        using the structure data precomputed by
        :meth:`precompute_cup_structure`.

        INPUT:

        - ``u`` -- cochain vector of degree ``dim_u``
        - ``v`` -- cochain vector of degree ``dim_v``
        - ``dim_u``, ``dim_v`` -- degrees of the cochains
        - ``ring`` -- (default: ``GF(2)``) coefficient ring

        OUTPUT: cochain vector of degree ``dim_u + dim_v``
        """
        u = self._as_vector(ring, u)
        v = self._as_vector(ring, v)

        structure = self.precompute_cup_structure(dim_u, dim_v, verbose=False)

        dim_tot = dim_u + dim_v
        n_tot = len(self.by_grade.get(dim_tot, []))
        res = SageVector(ring, n_tot)

        char2 = self._is_char2(ring)

        for (idx_target, idx_front, idx_back, sgn) in structure:
            val_u = u[idx_front]
            if val_u == 0:
                continue
            val_v = v[idx_back]
            if val_v == 0:
                continue
            term = val_u * val_v
            if char2 or sgn == 1:
                res[idx_target] += term
            else:
                res[idx_target] -= term

        return res

    def cup_product(self, u, v, deg_u, deg_v, ring=ZZ):
        r"""
        Cup product `u \smile v` via direct evaluation of the cubical diagonal.

        This is the non-precomputed version that evaluates the Serre
        diagonal cell-by-cell.  Suitable for one-off computations or
        verification against :meth:`fast_cup_product`.

        .. WARNING::

            This method uses only the **cubical (strictly commutative)
            diagonal formula** [CL, Theorem: Cubical Diagonal Reduction].
            For complexes containing non-commutative cells, use
            :meth:`fast_cup_product` which dispatches to the appropriate
            zonotopal diagonal.

        INPUT:

        - ``u`` -- cochain vector of degree ``deg_u``
        - ``v`` -- cochain vector of degree ``deg_v``
        - ``deg_u``, ``deg_v`` -- degrees of the cochains
        - ``ring`` -- (default: ``ZZ``) coefficient ring

        OUTPUT: cochain vector of degree ``deg_u + deg_v``
        """
        u = self._as_vector(ring, u)
        v = self._as_vector(ring, v)

        deg_tot = deg_u + deg_v
        cells_tot = self.by_grade.get(deg_tot, [])
        n_tot = len(cells_tot)
        res = SageVector(ring, n_tot)

        if n_tot == 0:
            return res

        char2 = self._is_char2(ring)

        for idx_target, (w, I) in enumerate(cells_tot):
            acc = ring.zero() if hasattr(ring, 'zero') else ring(0)

            # Safety check: the cubical Serre diagonal is only valid
            # for strictly commutative cells [CL, Theorem: Cubical
            # Diagonal Reduction].  For non-commutative cells, the
            # formula silently produces wrong results.
            if not self._is_commutative(I):
                raise NotImplementedError(
                    f"cup_product() uses the cubical Serre diagonal, which is "
                    f"only valid for strictly commutative cells (m_ij = 2 for "
                    f"all i,j in I).  Cell (w, I={I}) has non-commuting "
                    f"generators.  Use fast_cup_product() instead, which "
                    f"dispatches to the correct zonotopal diagonal for each "
                    f"cell type."
                )

            for partition_indices in itertools.combinations(range(len(I)), deg_u):
                partition_set = set(partition_indices)
                J_list, K_list = [], []
                shuffle_inversions = 0
                k_count = 0

                for pos in range(len(I)):
                    element = I[pos]
                    if pos in partition_set:
                        J_list.append(element)
                        shuffle_inversions += k_count
                    else:
                        K_list.append(element)
                        k_count += 1

                J = tuple(J_list)
                K = tuple(K_list)

                w_front = self._minimize_in_coset(w, J)
                idx_u = self.map_cell_to_idx.get((deg_u, (w_front, J)))
                if idx_u is None:
                    continue
                val_u = u[idx_u]
                if val_u == 0:
                    continue

                w0_J = self._get_w0_J(J)
                w_shifted = w * w0_J
                w_back = self._minimize_in_coset(w_shifted, K)
                idx_v = self.map_cell_to_idx.get((deg_v, (w_back, K)))
                if idx_v is None:
                    continue
                val_v = v[idx_v]
                if val_v == 0:
                    continue

                term = val_u * val_v
                if (not char2) and (shuffle_inversions % 2 == 1):
                    acc -= term
                else:
                    acc += term

            res[idx_target] = acc

        return res

    # ==========================================================================
    # Cohomology Computation
    # ==========================================================================

    def cohomology_basis(self, k, ring=GF(2)):
        r"""
        Compute a basis for `H^k(\mathscr{M}_{\mathscr{A}}; R)`.

        Uses the cellular cochain complex of `K_{\mathscr{A}}`:

        .. MATH::

            H^k(\mathscr{M}_{\mathscr{A}};R)
            \cong \ker(\delta^k) / \mathrm{im}(\delta^{k-1}).

        INPUT:

        - ``k`` -- non-negative integer (cohomological degree)
        - ``ring`` -- (default: ``GF(2)``) coefficient **field**

        OUTPUT:

        List of vectors representing a basis of `H^k` as lifts of
        generators of the quotient `\ker / \mathrm{im}`.

        .. NOTE::

            The ``ring`` must be a field (e.g. ``GF(2)``, ``QQ``).
            The computation relies on ``VectorSpace.subspace()`` and
            ``V.quotient(W)`` which require a field.  For integral
            (co)homology with torsion, use Smith Normal Form on the
            coboundary matrices obtained from :meth:`coboundary_matrix`.
        """
        if not ring.is_field():
            raise ValueError(
                f"cohomology_basis requires a field as coefficient ring, "
                f"but got {ring}.  For integral (co)homology over ZZ with "
                f"possible torsion, apply Smith Normal Form to the matrices "
                f"returned by coboundary_matrix()."
            )

        if k == 0:
            n_cells_0 = len(self.by_grade.get(0, []))
            prev_im = SageMatrix(ring, n_cells_0, 0)
        else:
            prev_im = self.coboundary_matrix(k - 1, ring)

        curr_map = self.coboundary_matrix(k, ring)
        if curr_map.ncols() == 0:
            return []

        ker_basis_matrix = curr_map.right_kernel().basis_matrix()
        V = SageVector(ring, [0] * curr_map.ncols()).parent()
        W_ker = V.subspace(ker_basis_matrix.rows()) if ker_basis_matrix.nrows() > 0 else V.zero_subspace()
        W_im = V.subspace(prev_im.columns()) if prev_im.ncols() > 0 else V.zero_subspace()

        try:
            Q = W_ker.quotient(W_im)
            return [Q.lift(gen) for gen in Q.basis()]
        except (ValueError, AttributeError, ArithmeticError, TypeError):
            return []

    # ==========================================================================
    # Euler Characteristic
    # ==========================================================================

    def euler_characteristic(self):
        r"""
        Compute the Euler characteristic of the complement `\mathscr{M}_{\mathscr{A}}`
        using the general alternating-sum formula (Proposition in paper):

        .. MATH::

            \chi(\mathscr{M}_{\mathscr{A}})
            \;=\; \sum_{\sigma \in \mathcal{C}(\mathscr{A})} (-1)^{\dim(\sigma)}
            \;=\; \sum_{J \subseteq S} (-1)^{|J|}\, N_J

        where `N_J` is the number of retained cosets of type `J`.

        OUTPUT: integer — the Euler characteristic.

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: arr = ParabolicArrangement(W, Plist, set())
            sage: arr.euler_characteristic()
            1
        """
        chi = ZZ(0)
        for k, cells_k in self.by_grade.items():
            chi += (-1)**k * len(cells_k)
        return chi

    def euler_characteristic_W_invariant(self, verbose=False):
        r"""
        Compute the Euler characteristic via the closed formula for
        `W`-invariant arrangements (Corollary in paper):

        .. MATH::

            \chi(\mathscr{M}_{\mathscr{A}})
            \;=\; |W| \sum_{J \in \mathcal{T}_{\mathscr{A}}}
            \frac{(-1)^{|J|}}{|W_J|}.

        Here `\mathcal{T}_{\mathscr{A}}` is the set of subset types `J`
        retained in the complex, and `|W_J|` is the order of the
        parabolic subgroup generated by `J`.

        This formula exploits the orbit structure: for each retained type
        `J`, there are exactly `|W|/|W_J|` cosets in the `W`-orbit, so
        the sum reduces to a weighted count over the quotient orbifold.

        INPUT:

        - ``verbose`` -- (default: ``False``) if ``True``, print per-type
          contributions and the breakdown of the formula.

        OUTPUT: a rational number (the Euler characteristic).

        .. NOTE::

            This method does NOT require that the arrangement be
            `W`-invariant; it simply applies the formula using the
            retained J-types.  For a truly `W`-invariant arrangement
            the result will agree with :meth:`euler_characteristic`.
            For non-invariant arrangements the result may differ.

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: arr = ParabolicArrangement(W, Plist, set())
            sage: arr.euler_characteristic_W_invariant()
            1
        """
        W_order = ZZ(len(self.W))

        # Collect the set of retained J-types
        retained_types = set()
        for (w, J) in self.cells:
            retained_types.add(J)

        weighted_sum = QQ(0)

        if verbose:
            print(f"  |W| = {W_order}")
            print(f"  Retained J-types: {len(retained_types)}")

        for J in sorted(retained_types, key=lambda x: (len(x), x)):
            k = len(J)
            W_J_order = self._parabolic_subgroup_order(J)
            contribution = QQ((-1)**k) / QQ(W_J_order)
            weighted_sum += contribution

            if verbose:
                N_J = W_order / W_J_order
                print(f"    J={J}:  |W_J|={W_J_order},  "
                      f"N_J=[W:W_J]={N_J},  "
                      f"(-1)^{k}/|W_J| = {contribution}")

        chi = W_order * weighted_sum

        if verbose:
            print(f"  Weighted sum = {weighted_sum}")
            print(f"  chi = |W| * sum = {W_order} * {weighted_sum} = {chi}")

        return chi

    def _parabolic_subgroup_order(self, J_tuple):
        r"""
        Return `|W_J|`, the order of the parabolic subgroup generated by `J`.

        Uses the longest element `w_{0,J}` to enumerate the subgroup via
        the Coxeter length relation, or falls back to direct enumeration.
        """
        if not J_tuple:
            return ZZ(1)

        # Use cached w0_J to compute via the subgroup
        try:
            # Direct: generate W_J as the subgroup generated by s_j for j in J
            gens = [self._sref[j] for j in J_tuple]
            W_J = set()
            frontier = {self.W.one()}
            while frontier:
                W_J.update(frontier)
                next_frontier = set()
                for g in frontier:
                    for s in gens:
                        gs = g * s
                        if gs not in W_J:
                            next_frontier.add(gs)
                frontier = next_frontier
            return ZZ(len(W_J))
        except Exception:
            # Fallback: use Lagrange via coset count
            count = len(set(
                self._minimize_in_coset(w, J_tuple) for w in self.W
            ))
            return ZZ(len(self.W)) // ZZ(count)

    # ==========================================================================
    # Geometric Asphericity Criteria
    # ==========================================================================

    def retained_graph(self):
        r"""
        Return the **retained graph** `\Gamma_{\mathscr{A}}`.

        This is the graph on vertex set `S` with an edge `\{s,t\}` for
        every retained rank-2 stratum (i.e. for every pair `(s,t)` such
        that the `W`-orbit of `wW_{\{s,t\}}` is present in
        `K_{\mathscr{A}}`) [CL, Section 4].

        OUTPUT:

        A SageMath ``Graph`` on vertices `S`.

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 3)
            sage: Delta = ideal_k_parabolic(W, Plist, k=3)
            sage: arr = ParabolicArrangement(W, Plist, Delta)
            sage: G = arr.retained_graph()
            sage: G.edges(labels=False)
            [(1, 3)]
        """
        # Collect surviving rank-2 J-types
        rank2_present = set()
        for (w, J) in self.cells:
            if len(J) == 2:
                rank2_present.add(J)

        G = Graph()
        G.add_vertices(self.S)
        for J in rank2_present:
            G.add_edge(J[0], J[1])
        return G

    def is_triangle_free(self, verbose=False):
        r"""
        Check the **Triangle-Free Criterion** for asphericity.

        For a `W`-invariant arrangement that removes all parabolic cosets
        of rank `\ge 3`, the complement `\mathscr{M}_{\mathscr{A}}` is a
        `K(\pi,1)` if and only if the retained graph
        `\Gamma_{\mathscr{A}}` is triangle-free [CL, Corollary:
        Triangle-Free Criterion].

        The proof relies on Moussong's Lemma: every edge in the vertex
        link has length `\ell_{st} = \pi - \pi/m_{st} \ge \pi/2`, so
        a 3-cycle has perimeter `< 2\pi` (violates CAT(1)), while any
        `k`-cycle with `k \ge 4` has perimeter `\ge 2\pi`.

        INPUT:

        - ``verbose`` -- (default: ``False``) print diagnostic info

        OUTPUT:

        Dictionary with keys:

        - ``'is_triangle_free'`` -- bool
        - ``'triangles'`` -- list of 3-element tuples (the triangles found)
        - ``'graph'`` -- the retained graph `\Gamma_{\mathscr{A}}`
        - ``'is_Kpi1'`` -- bool or ``None`` (``None`` if rank `\ge 3`
          strata survive, making the criterion inconclusive)

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 3)
            sage: Delta = ideal_k_parabolic(W, Plist, k=3)
            sage: arr = ParabolicArrangement(W, Plist, Delta)
            sage: result = arr.is_triangle_free()
            sage: result['is_triangle_free']
            True
        """
        G = self.retained_graph()
        triangles = []

        # Find all triangles (3-cliques) in the retained graph
        vertices = list(G.vertices())
        for i in range(len(vertices)):
            for j in range(i + 1, len(vertices)):
                if not G.has_edge(vertices[i], vertices[j]):
                    continue
                for k in range(j + 1, len(vertices)):
                    if (G.has_edge(vertices[i], vertices[k]) and
                            G.has_edge(vertices[j], vertices[k])):
                        triangles.append(
                            tuple(sorted([vertices[i], vertices[j], vertices[k]]))
                        )

        tf = len(triangles) == 0

        # Check if the criterion is conclusive: requires no rank >= 3 strata
        has_rank3_plus = any(len(J) >= 3 for (_, J) in self.cells)
        is_Kpi1 = None
        if not has_rank3_plus:
            is_Kpi1 = tf  # criterion is both necessary and sufficient

        if verbose:
            print(f"Retained graph: {G.num_verts()} vertices, "
                  f"{G.num_edges()} edges")
            if triangles:
                print(f"Triangles found ({len(triangles)}):")
                for tri in triangles:
                    cox = self.W.coxeter_matrix()
                    a, b, c = tri
                    perimeter = sum(
                        float(pi - pi / cox[x, y])
                        for x, y in [(a, b), (a, c), (b, c)]
                    )
                    print(f"  {tri}  (metric perimeter = "
                          f"{perimeter:.4f} < 2*pi = {2*float(pi):.4f})")
            else:
                print("No triangles found.")

            if has_rank3_plus:
                print("WARNING: Rank >= 3 strata survive in K_A; "
                      "the Triangle-Free Criterion is inconclusive.")
                print("  (The criterion requires ALL rank >= 3 "
                      "strata removed.)")
            else:
                if tf:
                    print("Conclusion: Gamma_A is triangle-free => "
                          "M_A is a K(pi,1).")
                else:
                    print("Conclusion: Gamma_A has triangles => "
                          "M_A is NOT a K(pi,1).")

        return {
            'is_triangle_free': tf,
            'triangles': triangles,
            'graph': G,
            'is_Kpi1': is_Kpi1,
        }

    def check_flag_criterion(self, verbose=False):
        r"""
        Check the **Flag Criterion** for asphericity.

        The Flag Criterion [CL, Theorem: Flag Criterion] states: if for
        every surviving vertex `w \in K_{\mathscr{A}}`, the link
        `L_w(K_{\mathscr{A}})` is a **metric flag complex**, then every
        connected component of `\mathscr{M}_{\mathscr{A}}` is a
        `K(\pi,1)` space.

        The link at each vertex `w` is a simplicial complex whose
        `k`-simplices correspond to `(k+1)`-element subsets `I` of `S`
        such that the coset `wW_I` is a cell of `K_{\mathscr{A}}`.
        The **flag condition** requires that every clique (complete
        subgraph) in the 1-skeleton of the link spans a simplex.

        Since `W` acts transitively on vertices (via the Cayley graph),
        for `W`-invariant arrangements it suffices to check the link at
        a single vertex (the identity).  For non-invariant arrangements,
        we check a representative sample or all vertices.

        .. NOTE::

            The Flag Criterion is sufficient but **not necessary** for
            asphericity [CL, Remark after Theorem: Flag Criterion].
            A failure means the complex is not locally CAT(0), but the
            universal cover may still be contractible.

        INPUT:

        - ``verbose`` -- (default: ``False``) print diagnostics

        OUTPUT:

        Dictionary with keys:

        - ``'is_flag'`` -- bool (True if all checked links are flag)
        - ``'violations'`` -- list of ``(vertex, clique)`` pairs where
          the flag condition fails
        - ``'vertices_checked'`` -- number of vertices inspected
        - ``'is_Kpi1'`` -- bool or ``None`` (True if flag holds;
          ``None`` if flag fails, since failure is inconclusive)

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 3)
            sage: Delta = ideal_k_parabolic(W, Plist, k=3)
            sage: arr = ParabolicArrangement(W, Plist, Delta)
            sage: result = arr.check_flag_criterion()
            sage: result['is_flag']
            True
        """
        violations = []

        # Determine which vertices to check.  For W-invariant arrangements
        # all vertex links are isomorphic, so check only the identity.
        # Otherwise check all vertices.
        vertices = self.by_grade.get(0, [])
        if not vertices:
            return {
                'is_flag': True,
                'violations': [],
                'vertices_checked': 0,
                'is_Kpi1': None,
            }

        w_invariant = self._check_J_type_invariant()

        if w_invariant:
            # All links are isomorphic; check only the identity
            check_verts = [vertices[0]]
        else:
            check_verts = vertices

        for vtx in check_verts:
            w_vtx = vtx[0]  # the group element at this vertex
            link_violations = self._check_link_flag(w_vtx)
            for clique in link_violations:
                violations.append((vtx, clique))

        is_flag = len(violations) == 0
        is_Kpi1 = True if is_flag else None  # Flag is sufficient, not necessary

        if verbose:
            print(f"Flag Criterion check:")
            print(f"  Vertices checked: {len(check_verts)}"
                  f"{' (W-invariant: single vertex suffices)' if w_invariant else ''}")
            if is_flag:
                print(f"  All vertex links are metric flag complexes.")
                print(f"  Conclusion: M_A is a K(pi,1) (locally CAT(0)).")
            else:
                print(f"  {len(violations)} flag violation(s) found:")
                for vtx, clique in violations[:10]:
                    print(f"    Vertex {vtx}: clique {clique} has all "
                          f"pairwise edges but no simplex")
                if len(violations) > 10:
                    print(f"    ... and {len(violations) - 10} more")
                print(f"  Conclusion: Not locally CAT(0).  "
                      f"(Asphericity is inconclusive.)")

        return {
            'is_flag': is_flag,
            'violations': violations,
            'vertices_checked': len(check_verts),
            'is_Kpi1': is_Kpi1,
        }

    def _check_J_type_invariant(self):
        r"""
        Quick check: are the surviving J-types consistent with
        `W`-invariance?  (i.e. for each J, either all `wW_J` or none
        are in `K_{\mathscr{A}}`.)

        This is a lightweight proxy for :meth:`is_W_invariant` that
        avoids the full orbit enumeration.
        """
        surviving_types = set()
        for (w, J) in self.cells:
            surviving_types.add(J)

        # Count cosets per J-type and compare to expected [W:W_J]
        from collections import Counter
        counts = Counter(J for (_, J) in self.cells)
        for J, count in counts.items():
            expected = ZZ(len(self.W)) // self._parabolic_subgroup_order(J)
            if count != expected:
                return False
        return True

    def _check_link_flag(self, w):
        r"""
        Check the flag condition on the link of vertex `w`.

        The link `L_w(K_{\mathscr{A}})` has:

        - Vertices: generators `s \in S` such that `(w, (s,))` is a cell.
        - Edges: pairs `\{s,t\}` such that `(w', (s,t))` is a cell
          where `w'` is the minimal rep in `wW_{\{s,t\}}`.
        - `k`-simplices: `(k+1)`-subsets `I` such that the cell
          `wW_I` (minimized) exists.

        Returns a list of cliques (as sorted tuples) that have all
        pairwise edges present but whose corresponding higher simplex
        is absent — i.e., the flag violations.
        """
        # Step 1: Determine link vertices (rank-1 strata through w)
        link_verts = set()
        for s in self.S:
            cell_s = self._canonize((w, (s,)))
            if (1, cell_s) in self.map_cell_to_idx:
                link_verts.add(s)

        if len(link_verts) < 3:
            return []  # Need at least 3 vertices for a triangle

        # Step 2: Determine link edges (rank-2 strata through w)
        link_edges = set()
        for s in link_verts:
            for t in link_verts:
                if s >= t:
                    continue
                J2 = tuple(sorted([s, t]))
                cell_2 = self._canonize((w, J2))
                if (2, cell_2) in self.map_cell_to_idx:
                    link_edges.add(J2)

        # Step 3: Determine link simplices of each dimension
        # and check: every clique in the 1-skeleton must span a simplex
        link_verts_list = sorted(link_verts)
        violations = []

        # Check all potential (k+1)-cliques for k >= 2
        # A clique of size m has all (m choose 2) edges present
        # but the m-subset might not be a simplex
        for size in range(3, len(link_verts_list) + 1):
            for clique in itertools.combinations(link_verts_list, size):
                # Check all pairwise edges are present
                all_edges = True
                for a in range(len(clique)):
                    for b in range(a + 1, len(clique)):
                        if tuple(sorted([clique[a], clique[b]])) not in link_edges:
                            all_edges = False
                            break
                    if not all_edges:
                        break

                if not all_edges:
                    continue

                # All edges present; check if the simplex exists
                I_tuple = tuple(sorted(clique))
                cell_I = self._canonize((w, I_tuple))
                if (len(I_tuple), cell_I) not in self.map_cell_to_idx:
                    violations.append(I_tuple)

        return violations

    def cup_product_span_analysis(self, ring=GF(2), max_pairs=None,
                                  prefer_small_support=True, verbose=True):
        r"""
        Analyze whether `H^2` is generated by cup products from `H^1`.

        For classical complex hyperplane arrangements, the Orlik--Solomon
        theorem dictates that the cohomology algebra is generated by
        degree-one classes.  In contrast, for real parabolic arrangements
        the multiplicative structure can fail to detect higher-dimensional
        topology: as shown in [CL, Section 9], the entire second
        cohomology may be **indecomposable**, arising from geometric
        2-spheres rather than from products of 1-classes.

        This method tests the span of `H^1 \smile H^1` inside `H^2`.

        INPUT:

        - ``ring`` -- (default: ``GF(2)``) coefficient ring
        - ``max_pairs`` -- (default: ``None``) limit on pairs to test
        - ``prefer_small_support`` -- (default: ``True``) sort by Hamming weight
        - ``verbose`` -- (default: ``True``) print progress

        OUTPUT:

        Dictionary with keys ``rank_generated``, ``dim_H2``,
        ``generating_pairs``, ``is_complete``, ``time``.
        """
        import time

        if verbose:
            print("=" * 60)
            print("CUP PRODUCT SPAN ANALYSIS")
            print("=" * 60)

        t_start = time.time()

        if verbose:
            print("\nComputing cohomology bases...")

        H1 = self.cohomology_basis(1, ring)
        H2 = self.cohomology_basis(2, ring)

        dim_H1 = len(H1)
        dim_H2 = len(H2)

        if verbose:
            print(f"  dim(H^1) = {dim_H1}")
            print(f"  dim(H^2) = {dim_H2}")

        if dim_H2 == 0:
            if verbose:
                print("\nH^2 = 0, trivially complete.")
            return {
                'rank_generated': 0, 'dim_H2': 0,
                'generating_pairs': [], 'is_complete': True,
                'time': time.time() - t_start
            }

        if dim_H1 < 2:
            if verbose:
                print(f"\ndim(H^1) = {dim_H1} < 2, cannot form products.")
            return {
                'rank_generated': 0, 'dim_H2': dim_H2,
                'generating_pairs': [], 'is_complete': False,
                'time': time.time() - t_start
            }

        if verbose:
            print("\nPrecomputing cup structure for (1,1)...")
        self.precompute_cup_structure(1, 1, verbose=verbose)

        if verbose:
            print("Building projection matrix...")

        n_C2 = len(self.by_grade.get(2, []))
        M_H2 = SageMatrix(ring, n_C2, dim_H2)
        for col_idx, vec in enumerate(H2):
            M_H2.set_column(col_idx, list(vec))

        M_d1 = self.coboundary_matrix(1, ring)
        Proj_Matrix = M_H2.augment(M_d1)

        total_pairs = dim_H1 * (dim_H1 - 1) // 2
        if max_pairs is not None:
            total_pairs = min(total_pairs, max_pairs)

        if verbose:
            print(f"\nAnalyzing {total_pairs} pairs...")

        if prefer_small_support:
            H1_indices = sorted(range(dim_H1), key=lambda i: H1[i].hamming_weight())
        else:
            H1_indices = list(range(dim_H1))

        Found_Space = SageMatrix(ring, dim_H2, 0)
        rank_found = 0
        generating_pairs = []
        pairs_tested = 0

        for i_idx in range(dim_H1):
            for j_idx in range(i_idx + 1, dim_H1):
                if rank_found == dim_H2:
                    break
                if pairs_tested >= total_pairs:
                    break
                pairs_tested += 1

                real_i = H1_indices[i_idx]
                real_j = H1_indices[j_idx]
                u = H1[real_i]
                v = H1[real_j]

                prod = self.fast_cup_product(u, v, 1, 1, ring)
                if prod.is_zero():
                    continue

                try:
                    sol = Proj_Matrix.solve_right(prod)
                    coords = sol[:dim_H2]
                except (ValueError, ArithmeticError):
                    continue

                if coords.is_zero():
                    continue

                M_test = Found_Space.augment(SageMatrix(ring, dim_H2, 1, list(coords)))
                new_rank = M_test.rank()

                if new_rank > rank_found:
                    rank_found = new_rank
                    Found_Space = M_test
                    generating_pairs.append((real_i, real_j))
                    if verbose:
                        print(f"[Hit #{len(generating_pairs)}] Pair ({real_i}, {real_j}) -> Rank {rank_found}/{dim_H2}")

            if rank_found == dim_H2:
                break

        t_elapsed = time.time() - t_start
        is_complete = (rank_found == dim_H2)

        if verbose:
            print("\n" + "=" * 60)
            if is_complete:
                print(f"SUCCESS: H^2 fully generated in {t_elapsed:.1f}s")
            else:
                print(f"INCOMPLETE: Only {rank_found}/{dim_H2} dimensions generated in {t_elapsed:.1f}s")
            print("=" * 60)

        return {
            'rank_generated': rank_found, 'dim_H1': dim_H1, 'dim_H2': dim_H2,
            'generating_pairs': generating_pairs, 'is_complete': is_complete,
            'time': t_elapsed
        }

    # ==========================================================================
    # DGA Structure Verification
    # ==========================================================================

    def verify_w0J_front_back(self, verbose=True):
        r"""
        Verify that `w_{0,J}` maps front faces to back faces.

        Checks the geometric property underlying the diagonal formula:
        for each rank-1 factor `s \in I`, the longest element
        `w_{0,\{s\}} = s` carries the front face `wW_J` to the back
        face `wsW_J`, and `w_{0,J}^2 = e` (involution property).
        """
        if verbose:
            print("--- Verifying w_{0,J} front/back face correspondence ---")

        all_ok = True

        for k in range(1, self.max_grade + 1):
            cells_k = self.by_grade.get(k, [])
            for (w, K) in cells_k:
                K_list = list(K)
                for pos, s_idx in enumerate(K_list):
                    J_single = (s_idx,)
                    w0_s = self._get_w0_J(J_single)
                    s_ref = self._sref[s_idx]
                    if w0_s != s_ref:
                        if verbose:
                            print(f"  [FAIL] w_{{0,{{{s_idx}}}}} = {w0_s} != s_{s_idx} = {s_ref}")
                        all_ok = False
                        continue
                    J = tuple(K_list[:pos] + K_list[pos + 1:])
                    w_front = self._minimize_in_coset(w, J)
                    w_back_via_s = self._minimize_in_coset(w * s_ref, J)
                    w_back_via_w0 = self._minimize_in_coset(w * w0_s, J)
                    if w_back_via_s != w_back_via_w0:
                        if verbose:
                            print(f"  [FAIL] Back face mismatch for ({w}, {K}), s={s_idx}")
                        all_ok = False

        for k in range(self.max_grade + 1):
            for (w, J) in self.by_grade.get(k, []):
                if len(J) > 0:
                    w0_J = self._get_w0_J(J)
                    if w0_J * w0_J != self.W.one():
                        if verbose:
                            print(f"  [FAIL] w_{{0,{J}}}^2 != e")
                        all_ok = False

        if verbose:
            if all_ok:
                print("  w_{0,J} front/back verification passed.")
            else:
                print("  w_{0,J} verification FAILED.")

        return all_ok

    def verify_diagonal_chain_map(self, ring=QQ, verbose=True):
        r"""
        Verify that the diagonal `\Delta` is a chain map.

        Checks the identity
        `(\partial \otimes 1 + 1 \otimes \partial) \circ \Delta = \Delta \circ \partial`
        on each cell-by-cell basis, which is required for the induced
        cup product to descend to cohomology [CL, Section 6].
        """
        if verbose:
            print(f"--- Verifying diagonal is a chain map over {ring} ---")

        all_ok = True

        def compute_delta_cell(w, I):
            result = {}
            I_list = list(I)
            for dim_left in range(len(I) + 1):
                for partition_indices in itertools.combinations(range(len(I)), dim_left):
                    partition_set = set(partition_indices)
                    J_list, K_list = [], []
                    shuffle_inversions = 0
                    k_count = 0
                    for pos in range(len(I)):
                        element = I_list[pos]
                        if pos in partition_set:
                            J_list.append(element)
                            shuffle_inversions += k_count
                        else:
                            K_list.append(element)
                            k_count += 1
                    J = tuple(J_list)
                    K = tuple(K_list)
                    dim_J = len(J)
                    dim_K = len(K)

                    w_front = self._minimize_in_coset(w, J)
                    idx_front = self.map_cell_to_idx.get((dim_J, (w_front, J)))
                    if idx_front is None:
                        continue

                    w0_J = self._get_w0_J(J)
                    w_shifted = w * w0_J
                    w_back = self._minimize_in_coset(w_shifted, K)
                    idx_back = self.map_cell_to_idx.get((dim_K, (w_back, K)))
                    if idx_back is None:
                        continue

                    sgn = ring(-1) if (shuffle_inversions % 2 == 1) else ring(1)
                    key = (dim_J, idx_front, dim_K, idx_back)
                    result[key] = result.get(key, ring(0)) + sgn
            return result

        def compute_boundary(k, cell_idx):
            if k <= 0:
                return []
            M = self.coboundary_matrix(k - 1, ring=ring)
            result = []
            for j in range(M.ncols()):
                c = M[cell_idx, j]
                if c != 0:
                    result.append((c, j))
            return result

        for k in range(1, self.max_grade + 1):
            cells_k = self.by_grade.get(k, [])
            cells_km1 = self.by_grade.get(k - 1, [])
            if not cells_k or not cells_km1:
                continue

            if verbose:
                print(f"  Checking degree {k} (boundary to {k-1})...")

            for j, (w, I) in enumerate(cells_k):
                rhs_tensor = {}
                bdry = compute_boundary(k, j)
                for (coeff, idx_km1) in bdry:
                    w_km1, I_km1 = cells_km1[idx_km1]
                    delta_terms = compute_delta_cell(w_km1, I_km1)
                    for key, val in delta_terms.items():
                        rhs_tensor[key] = rhs_tensor.get(key, ring(0)) + coeff * val

                lhs_tensor = {}
                delta_sigma = compute_delta_cell(w, I)
                for (deg_L, idx_L, deg_R, idx_R), coeff in delta_sigma.items():
                    if coeff == 0:
                        continue
                    bdry_L = compute_boundary(deg_L, idx_L)
                    for (c_bdry, idx_new_L) in bdry_L:
                        key = (deg_L - 1, idx_new_L, deg_R, idx_R)
                        lhs_tensor[key] = lhs_tensor.get(key, ring(0)) + coeff * c_bdry
                    koszul = ring(-1) if (deg_L % 2 == 1) else ring(1)
                    bdry_R = compute_boundary(deg_R, idx_R)
                    for (c_bdry, idx_new_R) in bdry_R:
                        key = (deg_L, idx_L, deg_R - 1, idx_new_R)
                        lhs_tensor[key] = lhs_tensor.get(key, ring(0)) + coeff * koszul * c_bdry

                all_keys = set(lhs_tensor.keys()) | set(rhs_tensor.keys())
                for key in all_keys:
                    lhs_val = lhs_tensor.get(key, ring(0))
                    rhs_val = rhs_tensor.get(key, ring(0))
                    if lhs_val != rhs_val:
                        all_ok = False
                        if verbose:
                            print(f"  [FAIL] Degree {k}, cell {j}={cells_k[j]}, "
                                  f"tensor key {key}: LHS={lhs_val}, RHS={rhs_val}")
                            if sum(1 for kk in all_keys
                                   if lhs_tensor.get(kk, ring(0)) != rhs_tensor.get(kk, ring(0))) > 3:
                                print(f"  ... (more failures in this cell)")
                                break

        if verbose:
            if all_ok:
                print("  Diagonal chain map verified.")
            else:
                print("  Diagonal chain map FAILED.")

        return all_ok

    def verify_associativity(self, ring=GF(2), trials=20, verbose=True):
        r"""
        Verify strict associativity of the cup product.

        Tests `(u \smile v) \smile w = u \smile (v \smile w)` on
        random cochains for all valid degree triples.
        """
        if verbose:
            print(f"--- Verifying cup product associativity over {ring} ---")

        all_ok = True

        triples = [(p, q, r)
                    for p in range(1, self.max_grade)
                    for q in range(1, self.max_grade)
                    for r in range(1, self.max_grade)
                    if p + q + r <= self.max_grade
                    and len(self.by_grade.get(p, [])) > 0
                    and len(self.by_grade.get(q, [])) > 0
                    and len(self.by_grade.get(r, [])) > 0
                    and len(self.by_grade.get(p + q + r, [])) > 0]

        if not triples:
            if verbose:
                print("  No valid degree triples to test.")
            return True

        for (p, q, r) in triples:
            if verbose:
                print(f"  Testing degrees ({p}, {q}, {r})...")

            n_p = len(self.by_grade[p])
            n_q = len(self.by_grade[q])
            n_r = len(self.by_grade[r])

            for trial in range(trials):
                u = SageVector(ring, [ring.random_element() for _ in range(n_p)])
                v = SageVector(ring, [ring.random_element() for _ in range(n_q)])
                w_vec = SageVector(ring, [ring.random_element() for _ in range(n_r)])

                uv = self.fast_cup_product(u, v, p, q, ring)
                lhs = self.fast_cup_product(uv, w_vec, p + q, r, ring)

                vw = self.fast_cup_product(v, w_vec, q, r, ring)
                rhs = self.fast_cup_product(u, vw, p, q + r, ring)

                if lhs != rhs:
                    all_ok = False
                    if verbose:
                        print(f"  [FAIL] Associativity at ({p},{q},{r}), trial {trial}")
                    return False

        if verbose:
            if all_ok:
                print("  Associativity verified.")

        return all_ok

    def verify_leibniz_rule(self, ring=GF(2), trials=20, use_fast=False, max_degree=None):
        r"""
        Verify the graded Leibniz rule for the DGA structure.

        Checks the identity [CL, Theorem: DGA]:

        .. MATH::

            \delta(u \smile v)
            = (\delta u) \smile v
            + (-1)^{\deg u}\, u \smile (\delta v)

        on random cochains for all valid degree pairs.
        """
        print(f"--- Verifying DGA Leibniz Rule over {ring} ---")

        char2 = self._is_char2(ring)
        prod = self.fast_cup_product if use_fast else self.cup_product

        if max_degree is None:
            max_degree = min(self.max_grade, 3)

        test_degrees = [(p, q) for p in range(1, max_degree)
                        for q in range(1, max_degree)
                        if p + q <= self.max_grade]

        if not test_degrees:
            print("No degree pairs to test (complex too small)")
            return True

        for (deg_u, deg_v) in test_degrees:
            print(f"Testing degrees ({deg_u}, {deg_v})...")

            d_u = self.coboundary_matrix(deg_u, ring)
            d_v = self.coboundary_matrix(deg_v, ring)
            d_sum = self.coboundary_matrix(deg_u + deg_v, ring)

            n_u = d_u.ncols()
            n_v = d_v.ncols()

            if n_u == 0 or n_v == 0:
                continue

            for trial in range(trials):
                u = SageVector(ring, [ring.random_element() for _ in range(n_u)])
                v = SageVector(ring, [ring.random_element() for _ in range(n_v)])

                uv = prod(u, v, deg_u, deg_v, ring)
                lhs = d_sum * uv

                du = d_u * u
                dv = d_v * v
                term1 = prod(du, v, deg_u + 1, deg_v, ring)
                term2 = prod(u, dv, deg_u, deg_v + 1, ring)

                if char2:
                    rhs = term1 + term2
                else:
                    if deg_u % 2 == 0:
                        rhs = term1 + term2
                    else:
                        rhs = term1 - term2

                if lhs != rhs:
                    print(f"[FAIL] Leibniz rule violation at degrees ({deg_u}, {deg_v}), trial {trial}")
                    print(f"  LHS (delta(u cup v)): {lhs}")
                    print(f"  RHS: {rhs}")
                    return False

        print("Leibniz Rule Verified: The DGA structure is consistent.")
        return True

    # ======================================================================
    #  FUNDAMENTAL GROUP  (pi_1)
    # ======================================================================

    def init_pi1(self, H_gens=None, proper_only=True, check_invariance=True):
        r"""
        Initialize fundamental-group data structures.

        Builds the Bridson--Haefliger complex-of-groups quotient
        `\mathcal{Y} = H \backslash \mathcal{X}_{\mathscr{A}}`
        together with orbits, stabilizers, transport elements `h_a`,
        and twisting elements `g_{a,b}` [CL, Section 3].

        The algorithm follows [BH99, Ch. III.\(\mathcal{C}\), Section 2.9]:

        1. For each vertex `\sigma \in V(\mathcal{Y})`, select a
           representative `\widetilde{\sigma}`.  The local group is
           `G_\sigma = \mathrm{Stab}_H(\widetilde{\sigma})`.
        2. For each edge `a`, choose a transport element `h_a \in H`
           such that `h_a \cdot t(\widetilde{a}) = \widetilde{t(a)}`.
        3. Local morphisms `\psi_a(g) = h_a g h_a^{-1}` and twisting
           elements `g_{a,b} = h_a h_b h_{ab}^{-1}` are determined.

        The resulting complex of groups is **developable** by construction
        since it arises from the global `H`-action on
        `\mathcal{X}_{\mathscr{A}}`.

        INPUT:

        - ``H_gens`` -- List of generators for the subgroup `H \le W`.
          If ``None``, uses the trivial subgroup `\{e\}`.
        - ``proper_only`` -- (default: ``True``) Keep only cells `(w, J)`
          with `J \subsetneq S` (boundary of the permutahedron).
        - ``check_invariance`` -- (default: ``True``) Verify
          `H`-invariance of the retained complex before building the
          quotient.  An arrangement `\mathscr{A}` is `H`-invariant if
          `X \in \mathscr{A} \Rightarrow hX \in \mathscr{A}` for all
          `h \in H` [CL, Definition in Section 3].

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 3)
            sage: Delta = ideal_k_parabolic(W, Plist, k=3)
            sage: arr = ParabolicArrangement(W, Plist, Delta)
            sage: arr.init_pi1()
        """
        self.rank = len(self.S)
        self.proper_only = bool(proper_only)

        # 1. Initialize Subgroup H
        if H_gens is None:
            self.H = self.W.subgroup([self.W.one()])
        else:
            self.H = self.W.subgroup(H_gens)

        self.H_elements = [self.W(h) for h in self.H]

        # Theory-consistent cell universe (default: proper parabolics only)
        if self.proper_only:
            self._pi1_cells = [c for c in self.cells if len(c[1]) < self.rank]
        else:
            self._pi1_cells = list(self.cells)

        self._pi1_by_grade = {}
        self._pi1_map_cell_to_idx = {}
        for c in self._pi1_cells:
            k = len(c[1])
            self._pi1_by_grade.setdefault(k, []).append(c)
        for k in self._pi1_by_grade:
            self._pi1_by_grade[k].sort(key=lambda x: (str(x[0]), x[1]))
            for idx, c in enumerate(self._pi1_by_grade[k]):
                self._pi1_map_cell_to_idx[(k, c)] = idx
        self._pi1_max_grade = max(self._pi1_by_grade.keys()) if self._pi1_by_grade else 0

        self._pi1_cells_set = set(self._pi1_cells)
        self._cell_types_by_rank = defaultdict(set)
        for _, J in self._pi1_cells:
            self._cell_types_by_rank[len(J)].add(J)

        # Core B&H Data Structures
        self.orbits = {}
        self.reps = {}
        self.stabilizers = {}

        self.Y = DiGraph()
        self.tree_edges = set()
        self.h_a = {}
        self.edge_data = {}
        self.edges_from = defaultdict(list)
        self.edge_by_source_target_cell = {}
        self.comp_edge = {}
        self.g_ab = {}

        if check_invariance and not self.is_H_invariant():
            sample = self.find_H_invariance_violation()
            msg = (
                "The retained complex is not H-invariant, so the H-action does "
                "not restrict to K_A. Provide an H-invariant arrangement or "
                "disable check_invariance explicitly. Sample violation: "
                f"{sample}"
            )
            raise ValueError(msg)

        self._build_complex_of_groups()
        self._pi1_initialized = True

    # ------------------------------------------------------------------
    # pi1 internal helpers
    # ------------------------------------------------------------------

    def _subset_tuples(self, include_full=False):
        r"""
        Return all sorted tuples J subseteq S.
        """
        max_r = self.rank if include_full else self.rank - 1
        out = []
        for r in range(0, max_r + 1):
            for J_list in combinations(self.S, r):
                out.append(tuple(J_list))
        return out

    def _act(self, h, cell):
        r"""
        Left-translate cell `(w, J)` by `h \in H` and canonicalize.

        The `H`-action on parabolic cosets is `h \cdot wW_J = (hw)W_J`.
        """
        w, J = cell
        hw = h * w
        return self._canonize((hw, J))

    def _build_complex_of_groups(self):
        r"""
        Execute Steps 1--3 of the Bridson--Haefliger algorithm.

        Constructs the complex of groups
        `\mathcal{G}_{\mathscr{A}}(\mathcal{Y})` following
        [BH99, Ch. III.\(\mathcal{C}\), Section 2.9]:

        - Step 1: Compute `H`-orbits, representatives, and stabilizers.
        - Step 2: Build the quotient scwol `\mathcal{Y}` (1-skeleton)
          and transport elements `h_a`.
        - Step 3: Compute composition table and twisting elements
          `g_{a,b} = h_a h_b h_{ab}^{-1}`.
        """
        print(f"--- Building Complex of Groups ---")
        print(f"Subgroup H size: {len(self.H_elements)}")

        # Step 1: Orbits and Stabilizers
        orbit_counter = 0
        for cell in self._pi1_cells:
            if cell not in self.orbits:
                orbit_id = f"v_{orbit_counter}"
                self.reps[orbit_id] = cell
                self.Y.add_vertex(orbit_id)

                stab = []
                for h in self.H_elements:
                    target_cell = self._act(h, cell)
                    self.orbits[target_cell] = orbit_id
                    if target_cell == cell:
                        stab.append(h)

                self.stabilizers[orbit_id] = stab
                orbit_counter += 1

        print(f"Quotient Space Y has {orbit_counter} objects (orbits).")

        # Step 2: Build Quotient Scwol 1-skeleton
        max_rank_cell = self.rank - 1 if self.proper_only else self.rank

        edge_counter = 0
        for source_orbit, cell in self.reps.items():
            w, J = cell
            J_set = set(J)
            missing = [s for s in self.S if s not in J_set]
            for r in range(len(J) + 1, max_rank_cell + 1):
                add_size = r - len(J)
                for extra in combinations(missing, add_size):
                    J_new = tuple(sorted(J_set | set(extra)))
                    w_new = self._minimize_in_coset(w, J_new)
                    target_cell = (w_new, J_new)

                    if (len(J_new), target_cell) not in self._pi1_map_cell_to_idx:
                        continue

                    target_orbit = self.orbits[target_cell]
                    edge_id = f"e_{edge_counter}"
                    edge_key = (source_orbit, target_orbit, edge_id)
                    self.Y.add_edge(source_orbit, target_orbit, edge_id)
                    edge_counter += 1

                    official_target = self.reps[target_orbit]
                    h_candidates = [self.W(h) for h in self.H_elements
                                    if self._act(h, target_cell) == official_target]
                    if not h_candidates:
                        raise ValueError(
                            f"CRITICAL: Transport element not found for "
                            f"{target_cell} -> {official_target}"
                        )
                    self.h_a[edge_key] = h_candidates[0]
                    self.edge_data[edge_key] = {
                        'source_orbit': source_orbit,
                        'target_orbit': target_orbit,
                        'source_cell': cell,
                        'target_cell': target_cell,
                        'h_candidates': h_candidates,
                    }
                    self.edges_from[source_orbit].append(edge_key)
                    self.edge_by_source_target_cell[(source_orbit, target_cell)] = edge_key

        # Step 3: Composition table and twisting elements g_{a,b}
        for a in self.Y.edges():
            u, v, _ = a
            h_a_val = self.W(self.h_a[a])
            for b in self.edges_from[v]:
                _, w, _ = b
                target_b = self.edge_data[b]['target_cell']
                tau_comp = self._canonize((h_a_val**(-1) * target_b[0], target_b[1]))

                c = self.edge_by_source_target_cell.get((u, tau_comp))
                if c is None:
                    raise ValueError(
                        f"Missing composite edge for a={a}, b={b}: "
                        f"no edge from orbit {u} to target cell {tau_comp}"
                    )

                h_b_val = self.W(self.h_a[b])
                h_c_val = self.W(self.h_a[c])
                g = h_a_val * h_b_val * h_c_val**(-1)
                rep_w = self.reps[w]
                if self._act(g, rep_w) != rep_w:
                    fixed = False
                    for h_c_alt in self.edge_data[c]['h_candidates']:
                        g_alt = h_a_val * h_b_val * self.W(h_c_alt)**(-1)
                        if self._act(g_alt, rep_w) == rep_w:
                            self.h_a[c] = self.W(h_c_alt)
                            g = g_alt
                            fixed = True
                            break
                    if not fixed:
                        raise ValueError(
                            f"Twisting element g_(a,b) not in stabilizer for a={a}, b={b}."
                        )

                self.comp_edge[(a, b)] = c
                self.g_ab[(a, b)] = g

    # ------------------------------------------------------------------
    # Invariance checks
    # ------------------------------------------------------------------

    def find_H_invariance_violation(self):
        r"""
        Return a witness ``(cell, h, h.cell)`` if H-invariance fails, else ``None``.
        """
        for cell in self._pi1_cells:
            for h in self.H_elements:
                moved = self._act(h, cell)
                if moved not in self._pi1_cells_set:
                    return (cell, self.W(h), moved)
        return None

    def is_H_invariant(self):
        r"""
        True iff the retained cells of `K_{\mathscr{A}}` are stable
        under the left action of `H`.

        `H`-invariance is required for the quotient scwol
        `\mathcal{Y} = H \backslash \mathcal{X}_{\mathscr{A}}` to
        be well-defined [CL, Definition in Section 3].
        """
        return self.find_H_invariance_violation() is None

    def is_W_invariant(self):
        r"""
        True iff the arrangement `\mathscr{A}` is `W`-invariant.

        An arrangement is `W`-invariant if it is a union of `W`-orbits
        in the parabolic coset poset, i.e. for each subset type `J`, either
        all cosets `wW_J` are retained or all are removed.
        """
        for J in self._subset_tuples(include_full=(not self.proper_only)):
            cosets_in_K = [c for c in self._pi1_cells if c[1] == J]
            seen = set()
            for w in self.W:
                seen.add(self._canonize((w, J)))
            cosets_total = len(seen)
            if 0 < len(cosets_in_K) < cosets_total:
                return False
        return True

    def assert_W_invariant(self):
        r"""
        Raise ``ValueError`` if the arrangement is not W-invariant.
        """
        if not self.is_W_invariant():
            raise ValueError(
                "The arrangement is not W-invariant. The modified-Coxeter "
                "formula requires W-invariance."
            )

    # ------------------------------------------------------------------
    # Theorem-based analysis (W-invariant case)
    # ------------------------------------------------------------------

    def has_all_rank1_strata(self):
        r"""
        True iff all codimension-1 walls (rank-1 strata, `|J|=1`) are
        retained in `K_{\mathscr{A}}`.

        This is a necessary hypothesis for the modified Coxeter
        presentation (Theorem: Presentation of the Orbifold Group).
        When all rank-1 strata survive, the 1-skeleton of
        `K_{\mathscr{A}}` coincides with the Cayley graph of `W`.
        """
        present = self._cell_types_by_rank.get(1, set())
        return all((s,) in present for s in self.S)

    def assert_orbifold_formula_hypotheses(self):
        r"""
        Check hypotheses for the modified-Coxeter presentation.

        The orbifold group `\Gamma_{\mathscr{A}}` admits the explicit
        presentation from [CL, Theorem: Presentation of the Orbifold
        Group] when:

        1. The arrangement is `W`-invariant.
        2. No rank-1 strata are removed (reflection hyperplanes retained).
        """
        self.assert_W_invariant()
        if not self.has_all_rank1_strata():
            raise ValueError(
                "Modified-Coxeter presentation requires retaining all rank-1 "
                "strata (codim-1 walls). Use CW route instead."
            )

    def removed_rank2_strata(self):
        r"""
        Return the set of pairs `(s, t)` whose rank-2 stratum is excised.

        In the `W`-invariant setting, removing a rank-2 stratum
        `\sigma_{st}` corresponds to setting the Coxeter relation
        `(st)^{m_{st}} = 1` to infinity in the orbifold group
        [CL, Corollary after Theorem: Presentation of the Orbifold Group].
        """
        present = set()
        for _, J in self._pi1_cells:
            if len(J) == 2:
                present.add(J)

        removed = set()
        for i in range(len(self.S)):
            for j in range(i + 1, len(self.S)):
                J = tuple(sorted([self.S[i], self.S[j]]))
                if J not in present:
                    removed.add(J)
        return removed

    def modified_coxeter_data(self):
        r"""
        Return the modified Coxeter matrix `\{(s,t): m'_{st}\}`.

        Implements the formula from [CL, Corollary]:

        .. MATH::

            m'_{st} = \begin{cases}
              m_{st} & \text{if } \sigma_{st} \text{ is retained},\\
              \infty & \text{if } \sigma_{st} \text{ is excised}.
            \end{cases}

        The orbifold group is then `\Gamma_{\mathscr{A}} \cong W(m')`.
        """
        removed = self.removed_rank2_strata()
        data = {}
        for i in range(len(self.S)):
            for j in range(i + 1, len(self.S)):
                s, t = self.S[i], self.S[j]
                J = tuple(sorted([s, t]))
                if J in removed:
                    data[(s, t)] = Infinity
                else:
                    data[(s, t)] = (self._sref[s] * self._sref[t]).order()
        return data

    def orbifold_group_presentation(self, verbose=False):
        r"""
        Build the orbifold group `\Gamma_{\mathscr{A}}` as a finitely
        presented group.

        Implements [CL, Theorem: Presentation of the Orbifold Group]:

        .. MATH::

            \Gamma_{\mathscr{A}}
            = \Big\langle S \;\Big|\;
              s^2 = 1,\;
              (st)^{m'_{st}} = 1 \text{ whenever } m'_{st} < \infty
              \Big\rangle.

        Requires `W`-invariance and retention of all rank-1 strata.

        OUTPUT:

        Tuple ``(G_A, idx_map)`` where ``G_A`` is a GAP finitely presented
        group and ``idx_map`` maps each `s \in S` to its generator index.
        """
        n = len(self.S)
        idx_map = {self.S[i]: i for i in range(n)}

        gen_names = ['s{}'.format(s) for s in self.S]
        F = FreeGroup(gen_names)
        fgens = F.generators()

        relations = []
        for i in range(n):
            relations.append(fgens[i] ** 2)

        m_data = self.modified_coxeter_data()
        for (s, t), m in m_data.items():
            if m != Infinity and m >= 2:
                i, j = idx_map[s], idx_map[t]
                relations.append((fgens[i] * fgens[j]) ** m)

        G_A = F / relations

        if verbose:
            print("G_A generators:", gen_names)
            print("Removed strata:", self.removed_rank2_strata())
            print("Modified Coxeter data:", m_data)

        return G_A, idx_map

    # ------------------------------------------------------------------
    # pi_1 via Orbifold Extension
    # ------------------------------------------------------------------

    def _build_rho(self, verbose=False):
        r"""
        Build `\Gamma_{\mathscr{A}}` and the monodromy homomorphism
        `\rho: \Gamma_{\mathscr{A}} \to \mathrm{Sym}(W)`.

        The kernel of `\rho` recovers the fundamental group
        [CL, Theorem: Orbifold Extension]:

        .. MATH::

            \pi_1(K_{\mathscr{A}}, x_0)
            \cong \ker(\rho).
        """
        self.assert_orbifold_formula_hypotheses()
        from sage.libs.gap.libgap import libgap

        G_A, idx_map = self.orbifold_group_presentation(verbose=verbose)
        G_A_gap  = G_A.gap()
        G_A_gens = list(G_A_gap.GeneratorsOfGroup())

        W_elts   = list(self.W)
        w_to_idx = {w: i + 1 for i, w in enumerate(W_elts)}

        gap_perms = []
        for s_idx in self.S:
            s = self._sref[s_idx]
            perm = [w_to_idx[s * w] for w in W_elts]
            gap_perms.append(libgap.PermList(perm))

        W_gap = libgap.Group(gap_perms)
        phi   = libgap.GroupHomomorphismByImages(G_A_gap, W_gap, G_A_gens, gap_perms)
        if phi == libgap.fail:
            raise ValueError("rho: G_A -> W is not well-defined.")

        if verbose:
            print(f"Removed rank-2 strata : {self.removed_rank2_strata()}")
            print(f"G_A: {len(self.S)} generators, {len(G_A.relations())} relations")
            print(f"rho: G_A -> Sym(W),  degree |W| = {len(W_elts)}")

        return dict(G_A=G_A, G_A_gap=G_A_gap, G_A_gens=G_A_gens,
                    W_elts=W_elts, gap_perms=gap_perms, W_gap=W_gap, phi=phi)

    # ------------------------------------------------------------------
    # CW 2-skeleton route (always valid)
    # ------------------------------------------------------------------

    def _compute_pi1_cw(self, verbose):
        r"""
        Compute `\pi_1(K_{\mathscr{A}})` directly from the CW 2-skeleton.

        This is the **always-valid** fallback method.  The fundamental
        group of a CW complex depends only on its 2-skeleton
        [CL, Section 3].  The method:

        1. Extracts the 1-skeleton (Cayley graph of `W`).
        2. Computes a spanning tree.
        3. Non-tree edges become generators.
        4. Boundary words of 2-cells become relators.

        This route does not require `H`- or `W`-invariance.
        """
        from sage.libs.gap.libgap import libgap

        vertices = list(self._pi1_by_grade.get(0, []))
        edges = list(self._pi1_by_grade.get(1, []))
        faces = list(self._pi1_by_grade.get(2, []))

        if not vertices:
            raise ValueError("K_A has no vertices; pi_1 is undefined.")

        vertex_set = set(vertices)
        edge_data = {}
        incident = defaultdict(list)

        for e in edges:
            w, J = e
            s_idx = J[0]
            s = self._sref[s_idx]
            u = self._canonize((w, ()))
            v = self._canonize((w * s, ()))
            if u not in vertex_set or v not in vertex_set:
                continue
            edge_data[e] = (u, v, s_idx)
            incident[u].append((e, v))
            incident[v].append((e, u))

        e0 = self._canonize((self.W.one(), ()))
        base = e0 if e0 in vertex_set else vertices[0]

        visited = set([base])
        q = deque([base])
        tree_edges = set()

        while q:
            u = q.popleft()
            for e, v in incident[u]:
                if v not in visited:
                    visited.add(v)
                    tree_edges.add(e)
                    q.append(v)

        if verbose and len(visited) < len(vertex_set):
            print(f"Warning: K_A is disconnected; computing pi_1 on component "
                  f"of basepoint ({len(visited)} / {len(vertex_set)} vertices).")

        comp_vertices = visited
        comp_edges = [e for e, (u, v, _) in edge_data.items()
                      if u in comp_vertices and v in comp_vertices]
        comp_faces = []
        for f in faces:
            w, J = f
            u = self._canonize((w, ()))
            if u in comp_vertices:
                comp_faces.append(f)

        non_tree_edges = [e for e in comp_edges if e not in tree_edges]
        gen_names = [f"x{i+1}" for i in range(len(non_tree_edges))]
        edge_to_gen_idx = {e: i for i, e in enumerate(non_tree_edges)}

        if verbose:
            print("=" * 60)
            print("pi_1(K_A) -- CW 2-skeleton route")
            print(f"  Vertices (component): {len(comp_vertices)}")
            print(f"  Edges (component)   : {len(comp_edges)}")
            print(f"  2-cells (component) : {len(comp_faces)}")
            print(f"  Generators          : {len(non_tree_edges)}")
            print("=" * 60)

        if not gen_names:
            triv = libgap.TrivialGroup()
            K_iso = triv.IsomorphismFpGroup()
            return K_iso.Range(), None

        F = FreeGroup(gen_names)
        fgens = F.generators()

        def oriented_edge_symbol(edge_cell, u_from, u_to):
            if edge_cell not in edge_to_gen_idx:
                return F.one()
            i = edge_to_gen_idx[edge_cell]
            u, v, _ = edge_data[edge_cell]
            if u_from == u and u_to == v:
                return fgens[i]
            if u_from == v and u_to == u:
                return fgens[i] ** (-1)
            raise ValueError(f"Inconsistent edge traversal for edge {edge_cell}")

        relators = []
        for f in comp_faces:
            w, J = f
            s_idx, t_idx = J
            s = self._sref[s_idx]
            t = self._sref[t_idx]
            m = (s * t).order()
            letters = [s_idx if i % 2 == 0 else t_idx for i in range(2 * m)]

            cur = w
            rel = F.one()
            for letter in letters:
                refl = self._sref[letter]
                nxt = cur * refl
                u_from = self._canonize((cur, ()))
                u_to = self._canonize((nxt, ()))
                e_cell = self._canonize((cur, (letter,)))
                if e_cell not in edge_data:
                    raise ValueError(f"2-cell {f} has boundary edge not in K_A: {e_cell}")
                rel *= oriented_edge_symbol(e_cell, u_from, u_to)
                cur = nxt

            if rel != F.one():
                relators.append(rel)

        G = F / relators
        K_gap = G.gap()
        K_iso = K_gap.IsomorphismFpGroup()
        K_fp = K_iso.Range()

        if verbose:
            K_ab = list(K_fp.AbelianInvariants())
            print(f"H_1(K_A; Z) = {K_ab}")

        return K_fp, None

    def _build_edge_cell_map(self):
        r"""
        Map each edge ``(u, v, label)`` in Y to ``(source_cell, raw_target_cell)``.
        """
        ecm = {}
        for k in range(self._pi1_max_grade):
            for cell in self._pi1_by_grade.get(k, []):
                src_oid = self.orbits[cell]
                if self.reps[src_oid] != cell:
                    continue
                w, J = cell
                J_set = set(J)
                for s_idx in self.S:
                    if s_idx in J_set:
                        continue
                    J_new = tuple(sorted(J_set | {s_idx}))
                    w_new = self._minimize_in_coset(w, J_new)
                    tgt_cell = (w_new, J_new)
                    if (len(J_new), tgt_cell) not in self._pi1_map_cell_to_idx:
                        continue
                    tgt_oid = self.orbits[tgt_cell]
                    for u, v, lab in self.Y.edges():
                        if u == src_oid and v == tgt_oid and (u, v, lab) not in ecm:
                            ecm[(u, v, lab)] = (cell, tgt_cell)
                            break
        return ecm

    def _compute_twisting_elements(self, edge_cell_map=None):
        r"""
        Compute twisting elements `g_{a,b}` for every composable pair.
        """
        if edge_cell_map is None:
            edge_cell_map = self._build_edge_cell_map()
        out_edges = defaultdict(list)
        for u, v, lab in self.Y.edges():
            out_edges[u].append((v, lab))
        result = {}
        for u, v, e_a in self.Y.edges():
            data_a = edge_cell_map.get((u, v, e_a))
            if data_a is None:
                continue
            h_a_val = self.W(self.h_a.get((u, v, e_a), self.W.one()))
            for w, e_b in out_edges[v]:
                data_b = edge_cell_map.get((v, w, e_b))
                if data_b is None:
                    continue
                _, tgt_b = data_b
                h_b_val  = self.W(self.h_a.get((v, w, e_b), self.W.one()))
                cell_hb  = self._canonize((h_b_val * tgt_b[0], tgt_b[1]))
                cell_hab = self._canonize((h_a_val * cell_hb[0], cell_hb[1]))
                rep_w = self.reps[w]
                g_ab  = None
                for h in self.H_elements:
                    if self._canonize((self.W(h) * cell_hab[0], cell_hab[1])) == rep_w:
                        g_ab = self.W(h)
                        break
                if g_ab is None:
                    raise ValueError(f"g_{{a,b}} not found for ({u},{v},{e_a}), ({v},{w},{e_b})")
                result[(u, v, e_a, v, w, e_b)] = g_ab
        return result

    # ------------------------------------------------------------------
    # Full Bridson-Haefliger route
    # ------------------------------------------------------------------

    def _compute_pi1_BH_full(self, verbose):
        r"""
        Full Bridson--Haefliger complex-of-groups computation of
        `\pi_1(K_{\mathscr{A}})`.

        Implements the orbifold extension from [CL, Theorem: Orbifold
        Extension] via the complex of groups
        `\mathcal{G}_{\mathscr{A}}(\mathcal{Y})` constructed in
        :meth:`init_pi1`.  The presentation of
        `\pi_1(\mathcal{G}_{\mathscr{A}}(\mathcal{Y}))` follows
        [BH99, Ch. III.\(\mathcal{C}\), Def. 3.5] and is converted
        to `\pi_1(K_{\mathscr{A}})` via the monodromy kernel
        `\ker(\rho_H: \Gamma_{\mathscr{A}} \to \mathrm{Sym}(H))`.

        The generators are:

        - **Local group generators**: from stabilizers
          `G_\sigma = \mathrm{Stab}_H(\widetilde{\sigma})`.
        - **Non-tree transport generators** `t_a`: for edges
          `a \in E(\mathcal{Y}) \setminus E(T)`.

        The relators encode:

        - (R1) Group law at each orbit.
        - (R2) Tree-edge identifications via `\psi_a`.
        - (R3) Non-tree conjugation relations.
        - (R4) Composability via twisting elements `g_{a,b}`.
        """
        from sage.libs.gap.libgap import libgap

        H_elts   = self.H_elements
        H_order  = len(H_elts)
        H_to_idx = {self.W(h): i + 1 for i, h in enumerate(H_elts)}

        # Spanning tree
        und_Y     = self.Y.to_undirected()
        raw_tree = und_Y.min_spanning_tree(algorithm='Kruskal')
        tree_list = []
        for u, v, lab in raw_tree:
            if (u, v, lab) in self.h_a:
                tree_list.append((u, v, lab))
            elif (v, u, lab) in self.h_a:
                tree_list.append((v, u, lab))
            else:
                raise ValueError(f"Tree edge ({u},{v},{lab}) is not an edge of Y.")

        tree_set  = {(u, v, lab) for u, v, lab in tree_list}
        tree_set |= {(v, u, lab) for u, v, lab in tree_list}
        NT_edges  = [(u, v, lab) for u, v, lab in self.Y.edges()
                     if (u, v, lab) not in tree_set]

        # Index local generators
        local_gens    = []
        local_gen_idx = {}
        for oid in sorted(self.reps.keys()):
            for h in self.stabilizers[oid]:
                hw = self.W(h)
                if hw != self.W.one() and (oid, hw) not in local_gen_idx:
                    local_gen_idx[(oid, hw)] = len(local_gens) + 1
                    local_gens.append((oid, hw))
        nt_gen_idx = {(u, v, lab): i + 1 for i, (u, v, lab) in enumerate(NT_edges)}
        n_gens = len(local_gens) + len(NT_edges)

        if verbose:
            print("=" * 60)
            print("pi_1(K_A) -- Full B&H Complex-of-Groups")
            print("Exact sequence: 1 -> pi_1(K_A) -> Gamma_A -> H -> 1")
            print(f"  Non-tree generators t_a : {len(NT_edges)}")
            print(f"  Local group generators  : {len(local_gens)}")
            print(f"  Total generators        : {n_gens}")
            print("=" * 60)

        if n_gens == 0:
            if verbose:
                print("Gamma_A is trivial => pi_1(K_A) is trivial.")
            triv = libgap.TrivialGroup()
            K_iso = triv.IsomorphismFpGroup()
            return K_iso.Range(), None

        F_gap  = libgap.FreeGroup(n_gens)
        F_gens = list(F_gap.GeneratorsOfGroup())
        F_one  = F_gap.One()

        def gamma(oid, h):
            hw = self.W(h)
            if hw == self.W.one():
                return F_one
            key = (oid, hw)
            return F_gens[local_gen_idx[key] - 1] if key in local_gen_idx else F_one

        def t_gen(u, v, lab):
            key = (u, v, lab)
            if key not in nt_gen_idx:
                return F_one
            return F_gens[len(local_gens) + nt_gen_idx[key] - 1]

        relators = []

        # R1: group law at each orbit
        for oid in sorted(self.reps.keys()):
            stab = [self.W(h) for h in self.stabilizers[oid]]
            for g in stab:
                for h in stab:
                    rel = gamma(oid, g) * gamma(oid, h) * gamma(oid, g * h)**(-1)
                    if rel != F_one:
                        relators.append(rel)

        # R2: tree-edge identification
        for u, v, lab in tree_list:
            h_a_val = self.W(self.h_a.get((u, v, lab), self.W.one()))
            for h in self.stabilizers[u]:
                g     = self.W(h)
                phi_g = h_a_val * g * h_a_val**(-1)
                rel   = gamma(v, phi_g) * gamma(u, g)**(-1)
                if rel != F_one:
                    relators.append(rel)

        # R3: non-tree conjugation
        for u, v, lab in NT_edges:
            h_a_val = self.W(self.h_a.get((u, v, lab), self.W.one()))
            ta  = t_gen(u, v, lab)
            for h in self.stabilizers[u]:
                g     = self.W(h)
                phi_g = h_a_val * g * h_a_val**(-1)
                rel   = ta * gamma(u, g) * ta**(-1) * gamma(v, phi_g)**(-1)
                if rel != F_one:
                    relators.append(rel)

        # R4: composability
        for (a, b), c in self.comp_edge.items():
            u, v, e_a = a
            _, w, e_b = b
            g_ab_val = self.W(self.g_ab[(a, b)])
            if g_ab_val != self.W.one() and (w, g_ab_val) not in local_gen_idx:
                raise ValueError(
                    f"Twisting element g_(a,b) not indexed in local group G_{w}"
                )
            ta = t_gen(u, v, e_a)
            tb = t_gen(v, w, e_b)
            t_ab = t_gen(c[0], c[1], c[2])
            rel = gamma(w, g_ab_val) * t_ab * (ta * tb)**(-1)
            if rel != F_one:
                relators.append(rel)

        Gamma_gap  = F_gap / relators if relators else F_gap
        Gamma_gens = list(Gamma_gap.GeneratorsOfGroup())

        def h_perm(h):
            hw = self.W(h)
            return libgap.PermList([H_to_idx[hw**(-1) * self.W(hj)] for hj in H_elts])

        img_list = [h_perm(hw) for (_, hw) in local_gens]
        img_list += [h_perm(self.W(self.h_a.get((u, v, lab), self.W.one())))
                     for (u, v, lab) in NT_edges]

        H_sym_H = libgap.Group(img_list) if img_list else libgap.TrivialGroup()
        phi_H   = libgap.GroupHomomorphismByImages(Gamma_gap, H_sym_H, Gamma_gens, img_list)
        if phi_H == libgap.fail:
            raise ValueError("Map Gamma_A -> Sym(H) is not well-defined.")

        if verbose:
            print(f"Map Gamma_A -> Sym(H) defined (degree |H| = {H_order}).")
            print("Computing ker(phi_H) ...")

        K_gap = phi_H.Kernel()
        K_iso = K_gap.IsomorphismFpGroup()
        K_fp  = K_iso.Range()

        if verbose:
            K_gens = list(K_fp.GeneratorsOfGroup())
            K_rels = list(K_fp.RelatorsOfFpGroup())
            K_ab   = list(K_fp.AbelianInvariants())
            print("-" * 60)
            print(f"pi_1(K_A): {len(K_gens)} generators, {len(K_rels)} relators")
            for g in K_gens:
                print(f"  {g}")
            for r in K_rels:
                print(f"  {r} = 1")
            print(f"H_1(K_A; Z) = {K_ab}")
            print("=" * 60)

        return K_fp, phi_H

    # ------------------------------------------------------------------
    # W-route
    # ------------------------------------------------------------------

    def _compute_pi1_W_route(self, verbose):
        r"""
        W-route: `\pi_1(K_{\mathscr{A}}) = \ker(\rho: \Gamma_{\mathscr{A}} \to \mathrm{Sym}(W))`.

        This is the most efficient route when the arrangement is
        `W`-invariant.  The orbifold group `\Gamma_{\mathscr{A}}` is a
        modified Coxeter group (with selected relations deleted), and
        `\pi_1` is recovered as the kernel of the natural projection
        onto `W` [CL, Theorem: Presentation of the Orbifold Group].
        """
        from sage.libs.gap.libgap import libgap

        if verbose:
            print("=" * 60)
            print("pi_1(K_A) -- W-route")
            print("Exact sequence: 1 -> pi_1(K_A) -> G_A -> W -> 1")
            print("=" * 60)

        rho = self._build_rho(verbose=verbose)
        phi = rho['phi']

        if verbose:
            print("Computing ker(rho) via GAP coset enumeration...")
        K_gap = phi.Kernel()
        K_iso = K_gap.IsomorphismFpGroup()
        K_fp  = K_iso.Range()

        if verbose:
            K_gens = list(K_fp.GeneratorsOfGroup())
            K_rels = list(K_fp.RelatorsOfFpGroup())
            K_ab   = list(K_fp.AbelianInvariants())
            print("-" * 60)
            print(f"pi_1(K_A): {len(K_gens)} generators, {len(K_rels)} relators")
            for g in K_gens:
                print(f"  {g}")
            for r in K_rels:
                print(f"  {r} = 1")
            print(f"H_1(K_A; Z) = {K_ab}")
            print("=" * 60)

        return K_fp, phi

    # ------------------------------------------------------------------
    # H-route (independent verification)
    # ------------------------------------------------------------------

    def _compute_pi1_H_route(self, verbose):
        r"""
        H-route: `\pi_1(K_{\mathscr{A}}) = \ker(\Gamma_{\mathscr{A}} \to \mathrm{Sym}(H))`.

        Independent verification route using a smaller permutation
        representation of degree `|H|` instead of `|W|`.  The
        intermediate group `\Gamma_{\mathscr{A}} = \rho^{-1}(H)`
        is computed as the preimage of `H \le \mathrm{Sym}(W)`
        under the monodromy `\rho`.
        """
        from sage.libs.gap.libgap import libgap

        H_elts    = self.H_elements
        H_order   = len(H_elts)
        W_order   = self.W.cardinality()

        if verbose:
            print("=" * 60)
            print("pi_1(K_A) -- H-route (independent verification)")
            print("Exact sequence: 1 -> pi_1(K_A) -> Gamma_A -> H -> 1")
            print(f"  |H| = {H_order},  |W| = {W_order},  [W:H] = {W_order // H_order}")
            print(f"  Coset enumeration degree: |H| = {H_order}")
            print("=" * 60)

        rho       = self._build_rho(verbose=verbose)
        G_A_gap   = rho['G_A_gap']
        W_elts    = rho['W_elts']
        gap_perms = rho['gap_perms']
        phi       = rho['phi']

        def _w_to_sym_W(w):
            word = list(self.W(w).reduced_word())
            p = libgap.PermList(list(range(1, len(W_elts) + 1)))
            for i_s in word:
                p = p * gap_perms[self.S.index(i_s)]
            return p

        H_in_sym_W = libgap.Group([_w_to_sym_W(h) for h in H_elts])
        if verbose:
            print("Computing Gamma_A = rho^{-1}(H) ...")
        Gamma_gap = libgap.PreImage(phi, H_in_sym_W)

        expected_index = W_order // H_order
        actual_index   = int(G_A_gap.Index(Gamma_gap))
        if actual_index != expected_index:
            raise ValueError(
                f"Index mismatch: [G_A:Gamma_A] = {actual_index}, "
                f"expected [W:H] = {expected_index}"
            )
        if verbose:
            print(f"[G_A : Gamma_A] = {actual_index} = [W : H]  (check passed)")

        H_to_idx = {self.W(h): i + 1 for i, h in enumerate(H_elts)}

        def _h_to_sym_H(h):
            hw = self.W(h)
            perm = [H_to_idx[hw**(-1) * self.W(h_j)] for h_j in H_elts]
            return libgap.PermList(perm)

        e_W     = self.W.one()
        e_W_idx = next(i + 1 for i, w in enumerate(W_elts) if w == e_W)

        H_sage_gens  = [self.W(g) for g in self.H.gens()]
        H_gens_sym_W = [_w_to_sym_W(g) for g in H_sage_gens]
        H_gens_sym_H = [_h_to_sym_H(g) for g in H_sage_gens]
        H_sym_H      = libgap.Group(H_gens_sym_H)
        iso_H        = libgap.GroupHomomorphismByImages(
            H_in_sym_W, H_sym_H, H_gens_sym_W, H_gens_sym_H
        )
        if iso_H == libgap.fail:
            raise ValueError("Could not build isomorphism between two H representations.")

        Gamma_gens      = list(Gamma_gap.GeneratorsOfGroup())
        Gamma_imgs_in_H = [iso_H.ImageElm(phi.ImageElm(g)) for g in Gamma_gens]
        phi_H = libgap.GroupHomomorphismByImages(
            Gamma_gap, H_sym_H, Gamma_gens, Gamma_imgs_in_H
        )
        if phi_H == libgap.fail:
            raise ValueError("rho_H: Gamma_A -> Sym(H) is not well-defined.")

        if verbose:
            print(f"rho_H: Gamma_A -> Sym(H),  degree |H| = {H_order}")

        if verbose:
            print("Computing ker(rho_H) ...")
        K_gap = phi_H.Kernel()
        K_iso = K_gap.IsomorphismFpGroup()
        K_fp  = K_iso.Range()

        if verbose:
            print("Running IsomorphismFpGroup for Gamma_A...")
        Gamma_iso = Gamma_gap.IsomorphismFpGroup()
        Gamma_fp  = Gamma_iso.Range()
        self._Gamma_fp = Gamma_fp

        if verbose:
            G_gens = list(Gamma_fp.GeneratorsOfGroup())
            G_rels = list(Gamma_fp.RelatorsOfFpGroup())
            G_ab   = list(Gamma_fp.AbelianInvariants())
            K_gens = list(K_fp.GeneratorsOfGroup())
            K_rels = list(K_fp.RelatorsOfFpGroup())
            K_ab   = list(K_fp.AbelianInvariants())
            print("-" * 60)
            print(f"Gamma_A: {len(G_gens)} generators, {len(G_rels)} relators,  H_1 = {G_ab}")
            print(f"pi_1(K_A): {len(K_gens)} generators, {len(K_rels)} relators")
            for g in K_gens:
                print(f"  {g}")
            for r in K_rels:
                print(f"  {r} = 1")
            print(f"H_1(K_A; Z) = {K_ab}")
            print("=" * 60)

        return Gamma_fp, K_fp, phi_H

    # ------------------------------------------------------------------
    # Public dispatch
    # ------------------------------------------------------------------

    def compute_pi1(self, verbose=True, method='auto'):
        r"""
        Compute `\pi_1(K_{\mathscr{A}}) \cong \pi_1(\mathscr{M}_{\mathscr{A}})`.

        By the homotopy equivalence
        `\mathscr{M}_{\mathscr{A}} \simeq |K_{\mathscr{A}}|`,
        this computes the fundamental group of the arrangement complement.

        INPUT:

        - ``method`` -- ``'auto'`` | ``'w_route'`` | ``'bh_full'`` | ``'cw'``

          - ``'w_route'``: modified Coxeter extension (requires
            `W`-invariance and rank-1 strata retained).
          - ``'bh_full'``: Bridson--Haefliger complex of groups
            (requires `H`-invariance and rank-1 strata retained).
          - ``'cw'``: direct CW 2-skeleton computation (always valid).
          - ``'auto'``: selects the best available route.

        OUTPUT:

        Tuple ``(K_fp, phi)`` where ``K_fp`` is a GAP finitely presented
        group isomorphic to `\pi_1(K_{\mathscr{A}})` and ``phi`` is the
        monodromy homomorphism (when applicable).

        .. NOTE::

            You must call :meth:`init_pi1` before using this method.

        .. WARNING::

            The internal conversion to a finitely presented group via
            GAP's ``IsomorphismFpGroup()`` has worst-case **exponential**
            time complexity.  For arrangements with very large index
            `[W:H]` or high rank, this step may consume excessive
            memory or appear to hang.  Monitor resource usage when
            working with Coxeter groups of rank `\ge 6` or index
            `[W:H] > 10^4`.
        """
        if not self._pi1_initialized:
            raise RuntimeError(
                "Pi1 data not initialized. Call init_pi1() first."
            )

        method = str(method).lower()
        if method not in {'auto', 'w_route', 'bh_full', 'cw'}:
            raise ValueError("method must be one of: 'auto', 'w_route', 'bh_full', 'cw'")

        if method == 'w_route':
            self.assert_orbifold_formula_hypotheses()
            return self._compute_pi1_W_route(verbose)

        if method == 'bh_full':
            if not self.has_all_rank1_strata():
                raise ValueError(
                    "B&H full route assumes all rank-1 strata are retained."
                )
            return self._compute_pi1_BH_full(verbose)

        if method == 'cw':
            return self._compute_pi1_cw(verbose)

        # method == 'auto'
        if self.is_W_invariant() and self.has_all_rank1_strata():
            if verbose:
                print("Using W-route (modified Coxeter extension).")
            return self._compute_pi1_W_route(verbose)

        if self.has_all_rank1_strata():
            if verbose:
                print("Using full Bridson-Haefliger route (H-invariant setting).")
            try:
                return self._compute_pi1_BH_full(verbose)
            except Exception as e:
                if verbose:
                    print(f"B&H route failed ({type(e).__name__}: {e}). "
                          f"Falling back to CW route.")
                return self._compute_pi1_cw(verbose)

        if verbose:
            print("Using robust CW route.")
        return self._compute_pi1_cw(verbose)

    def verify_with_H_route(self, verbose=True):
        r"""
        Verify `\pi_1(K_{\mathscr{A}})` via the independent H-based
        exact sequence.

        Uses the short exact sequence
        `1 \to \pi_1(K_{\mathscr{A}}) \to \Gamma_{\mathscr{A}}
        \xrightarrow{\rho_H} H \to 1`
        for independent cross-validation against the W-route.

        OUTPUT: Tuple ``(Gamma_fp, K_fp, phi_H)``.
        """
        if not self._pi1_initialized:
            raise RuntimeError("Pi1 data not initialized. Call init_pi1() first.")
        self.assert_orbifold_formula_hypotheses()
        return self._compute_pi1_H_route(verbose)

    def pi1_abelianization(self, verbose=True):
        r"""
        Abelian invariants of `\pi_1(K_{\mathscr{A}})`, which equal
        `H_1(K_{\mathscr{A}}; \mathbb{Z})` by the Hurewicz theorem.
        """
        K_fp, _ = self.compute_pi1(verbose=verbose)
        ab = list(K_fp.AbelianInvariants())
        if verbose:
            print(f"H_1(K_A; Z) abelian invariants: {ab}")
        return ab

    # Legacy alias
    def compute_fundamental_group(self, verbose=True, method='auto'):
        r"""Legacy alias for :meth:`compute_pi1`."""
        if verbose:
            print("compute_fundamental_group() is deprecated; delegating to compute_pi1().")
        return self.compute_pi1(verbose=verbose, method=method)


# ==============================================================================
# Backward Compatibility Aliases
# ==============================================================================

ParabolicArrangementCohomology = ParabolicArrangement


def ParabolicArrangementPi1(dga, H_gens=None, proper_only=True,
                            check_invariance=True):
    r"""
    Backward-compatible wrapper that initializes `\pi_1` data on an
    existing :class:`ParabolicArrangement` instance and returns it.

    .. DEPRECATED::

        Use ``arr.init_pi1(...)`` directly on a :class:`ParabolicArrangement`
        instance instead.

    INPUT:

    - ``dga`` -- A :class:`ParabolicArrangement` instance
    - ``H_gens`` -- Generators for subgroup `H \le W` (default: trivial)
    - ``proper_only`` -- (default: ``True``) Restrict to proper parabolics
    - ``check_invariance`` -- (default: ``True``) Check `H`-invariance

    OUTPUT: The same ``dga`` instance, with `\pi_1` data initialized.
    """
    dga.init_pi1(H_gens=H_gens, proper_only=proper_only,
                 check_invariance=check_invariance)
    return dga


# ==============================================================================
# Construction Helpers
# ==============================================================================

def build_W_P(weyl_type, weyl_rank):
    r"""
    Construct Weyl group and face poset of the Coxeter complex.

    Returns the Weyl group `W`, the list of all parabolic cosets
    (face poset of `\mathcal{C}(W)`), and the poset object.

    INPUT:

    - ``weyl_type`` -- Cartan type (``'A'``, ``'B'``, ``'C'``, ``'D'``,
      ``'E'``, ``'F'``, ``'G'``)
    - ``weyl_rank`` -- Rank (positive integer)

    OUTPUT:

    Tuple ``(W, Plist, Pobj)`` where ``Plist`` is the list of
    parabolic cosets and ``Pobj`` is the SageMath poset object.

    .. NOTE::

        Non-crystallographic types (`H_3`, `H_4`, `I_2(m)`) are not
        supported by SageMath's ``RootSystem`` interface, even though
        the mathematical theory of [CL] applies to them.
    """
    W = RootSystem([weyl_type, Integer(weyl_rank)]).ambient_space().weyl_group()
    Pobj = W.milnor_fiber_poset()
    Plist = list(Pobj)
    return W, Plist, Pobj


def ideal_k_parabolic(W, Plist, k=3):
    r"""
    Construct the order ideal defining the `k`-parabolic arrangement.

    The `k`-parabolic arrangement `\mathscr{A}_k` excises the fixed
    subspaces associated with all **irreducible** (connected) parabolic
    subgroups of rank `\ge k-1` [CL, Section 1; BSW11].

    For `k = 3`, this removes all irreducible rank-2 strata, i.e.
    all `W_{\{s,t\}}` with `m_{st} \ge 3` (non-commuting pairs).
    By [CL, Lemma: Cube], every surviving cell in `K_{\mathscr{A}_3}`
    is then **strictly commutative**, making the cubical diagonal
    formula exact for the entire complex.

    INPUT:

    - ``W`` -- Weyl group
    - ``Plist`` -- List of all parabolic cosets (face poset)
    - ``k`` -- (default: 3) parameter defining the arrangement;
      removes irreducible parabolic subgroups of rank `\ge k-1`

    OUTPUT:

    Set of cells `(w, J)` to be excluded from the permutahedral complex.

    EXAMPLES::

        sage: W, Plist, _ = build_W_P('A', 3)
        sage: Delta = ideal_k_parabolic(W, Plist, k=3)
        sage: # Delta contains all cosets wW_J where J has a connected
        sage: # component of size >= 2 in the Dynkin diagram
    """
    ct = W.cartan_type()
    dynkin_graph = Graph(ct.dynkin_diagram())

    threshold = k - 1
    Delta = set()

    for c in Plist:
        if not (isinstance(c, tuple) and len(c) == 2 and isinstance(c[1], (tuple, list))):
            continue

        w, J = c

        if len(J) < threshold:
            continue

        subgraph = dynkin_graph.subgraph(vertices=list(J))
        components = subgraph.connected_components()

        if any(len(comp) >= threshold for comp in components):
            Delta.add(c)

    return Delta


# Alias for backward compatibility with type A literature
ideal_non_k_equal = ideal_k_parabolic
