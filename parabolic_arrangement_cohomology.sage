# -*- coding: utf-8 -*-
r"""
Cohomology Ring of Real Parabolic Arrangement Complements
==========================================================

OVERVIEW
--------

This module computes the **cohomology ring** of complements of **real parabolic
subspace arrangements** associated to a finite Weyl (Coxeter) group `W`.

For real parabolic arrangements, the complement is homotopy equivalent to a
**restricted Coxeter permutahedron** `Perm_A(W) ⊂ Perm(W)`, obtained by deleting
cells dual to the arrangement in the Coxeter complex. The resulting cellular
cochain complex admits:

1. A **coboundary operator** induced by canonical orientations of parabolic cells.
2. A **cup product** induced by a **cubical (Serre) diagonal**, transported to
   parabolic cosets via the Coxeter permutahedron's zonotopal/cubical structure.

This yields a computationally tractable model for large arrangements, avoiding
barycentric subdivision and enabling fast cup products via precomputed incidence
data.

MATHEMATICAL BACKGROUND
-----------------------

Let `W` be a finite Weyl group of rank `n` with simple reflections `S`.
Parabolic subgroups are `W_I ≤ W` generated by `I ⊆ S`, and **parabolic cosets**
are `wW_I` with `w ∈ W`.

A **parabolic arrangement** `A` is a collection of parabolic cosets forming a
filter under inclusion (equivalently, an order ideal in the face poset of the
Coxeter complex). The associated complement is the open set

    `M_A = |Σ(W)| \ |A|`.

Rather than working directly on the Coxeter complex, we use the order-reversing
duality between the Coxeter complex and the **Coxeter permutahedron**:

- `F(Σ(W))^op ≅ F(Perm(W))`.

The complement is homotopy equivalent to the **restricted permutahedron**
`Perm_A(W)`, the subcomplex of `Perm(W)` consisting of cells dual to faces not
in the arrangement. This is the cellular model computed in this module.


CELLULAR CHAIN/COCHAIN COMPLEX
------------------------------

Cells are indexed by parabolic cosets `wW_I` with `I ⊆ S`. The grading used in
this module is:

    `deg(wW_I) = |I|`  (equivalently, codimension in the Coxeter complex).

Orientations are fixed using the total order on `S`. The boundary/coboundary
signs depend only on the ordered index set `I`:

    `∂(wW_I) = Σ_{j ∈ S \ I} (-1)^{o_I(j)} wW_{I ∪ {j}}`,
    where `o_I(j) = |{ i ∈ I : i < j }|`.

This yields a well-defined chain complex, and the module implements the dual
coboundary operator `δ`.

CELLULAR DIAGONAL AND CUP PRODUCT
---------------------------------

The Coxeter permutahedron admits a canonical **zonotopal realization** as a root
zonotope, hence as a projection of a cube. Each parabolic cell `wW_I` carries
cubical combinatorics (Boolean face lattice), and we define a cellular diagonal
map by transporting the **Serre diagonal on the cube**.

For `J ⊔ K = I` an ordered partition (shuffle), let `w_{0,J}` denote the longest
element in the parabolic subgroup `W_J`. The diagonal on chains is:

    `Δ(wW_I) = Σ_{J ⊔ K = I} ε(J,K) (wW_J) ⊗ (w w_{0,J} W_K)`,

where `ε(J,K) = (-1)^{inv(J,K)}` is the shuffle sign (number of inversions
between `J` and `K` in the induced order on `I`).

Dualizing this diagonal yields the explicit cup product on cochains:

    `(u ∪ v)(wW_I) = Σ_{J ⊔ K = I} ε(J,K) · u(wW_J) · v(w w_{0,J} W_K)`.

DGA PROPERTIES
--------------

Because the diagonal is (cellularly) identified with the Serre diagonal on the
cube, the induced product on cochains is:

- **Associative** (strictly),
- satisfies the **graded Leibniz rule**:
      `δ(u ∪ v) = (δu) ∪ v + (-1)^{deg u} u ∪ (δv)`.

As in standard cubical/simplicial models, the cochain-level product is not
expected to be strictly graded-commutative; graded-commutativity holds on
cohomology (or up to coboundary).

IMPLEMENTATION NOTES
--------------------

1. Canonical cell representation
   Each cell is stored as `(w_min, I_sorted)` where `w_min` is the minimal-length
   representative of the coset `wW_I` and `I_sorted` is a sorted tuple. This
   ensures deterministic indexing and fast membership tests.

2. Relative (arrangement) model
   The arrangement is specified by a set/ideal `Delta` of excluded cells. The
   complex is built by removing these cells, corresponding to quotienting out
   the subcomplex lying in the arrangement.

3. Caching for performance
   - Longest elements `w_{0,J}` are cached.
   - Minimal coset representatives are cached with a bounded LRU policy.
   - Cup product incidence data for degrees `(p,q)` is precomputed and reused.

PERFORMANCE CHARACTERISTICS
---------------------------

For type `A_n` the number of parabolic cosets grows like `|W|·2^n` (with `|W|= (n+1)!`).
Cup structure precomputation at degrees `(p,q)` costs roughly
`|C^{p+q}|·binom(p+q, p)` and is cached.

EXAMPLES
--------

Compute cohomology of the 3-equal (k-parabolic) arrangement in type `A_3`::

    sage: from parabolic_arrangement_cohomology import *
    sage: W, Plist, _ = build_W_P('A', 3)
    sage: Delta = ideal_k_parabolic(W, Plist, k=3)
    sage: cohom = ParabolicArrangementCohomology(W, Plist, Delta)
    sage:
    sage: for k in range(cohom.max_grade + 1):
    ....:     basis = cohom.cohomology_basis(k, ring=GF(2))
    ....:     print(f"H^{k} has dimension {len(basis)}")
    sage:
    sage: cohom.verify_leibniz_rule(ring=GF(3), trials=20, use_fast=True)

MATHEMATICAL FOUNDATION
-----------------------

This implementation is derived from the mathematical theory developed in:

    **J. L. León-Medina and J. Cantarero**,
    *"The Topology of Real Parabolic Arrangements"*,
    manuscript in preparation.

The theory establishes that the complement of a real parabolic arrangement is
homotopy equivalent to a restricted Coxeter permutahedron, and constructs an
explicit cellular DGA structure using the zonotopal realization.

Additional references:

- A. Björner and G. Ziegler, "Combinatorial stratification of complex arrangements",
  J. Amer. Math. Soc. 5 (1992), 105–149. (Bjorner duality)
- M. Davis, *The Geometry and Topology of Coxeter Groups*, Princeton Univ. Press, 2008.
- J.-P. Serre, "Homologie singulière des espaces fibrés. Applications",
  Ann. of Math. (1951). (cubical diagonal)

NOTES
-----

- This code targets **real** arrangements (Davis complex), not complexified
  arrangements (Salvetti complex). Reflections satisfy s² = 1.
- Portions of the implementation were developed with AI assistance and have been
  rigorously verified against the mathematical theory.

VERSION: 1.2 (February 2026)
"""


from sage.all import (
    RootSystem, Integer, ZZ, GF, QQ,
    cached_method, cached_function
)
# Use aliased imports to avoid namespace collisions in notebooks
from sage.all import Matrix as SageMatrix
from sage.all import vector as SageVector
from sage.graphs.graph import Graph
from sage.rings.finite_rings.finite_field_base import FiniteField
from collections import OrderedDict
import itertools


# ==============================================================================
# Main Class
# ==============================================================================

class ParabolicArrangementCohomology(object):
    r"""
    Cohomology Ring of a Parabolic Arrangement Complement.

    This class computes the cellular cochain complex `C^*(M, R)` and cohomology
    ring of a parabolic arrangement complement `M`, equipped with the coboundary
    operator `\delta` and zonotopal cup product `\cup`.

    ATTRIBUTES:

    - ``W`` -- The ambient Weyl group
    - ``cells`` -- List of admissible cells in canonical form `(w, J)`
    - ``by_grade`` -- Dictionary `k \mapsto [cells of dimension k]`
    - ``map_cell_to_idx`` -- Fast lookup: `(k, cell) \mapsto index`
    - ``max_grade`` -- Maximum cell dimension
    - ``ring`` -- Default coefficient ring (can be overridden per computation)

    PRIVATE ATTRIBUTES (for caching):

    - ``_sref`` -- Simple reflections dictionary (computed once)
    - ``_w0_cache`` -- Cache of longest elements `w_{0,J}` for parabolics
    - ``_min_cache`` -- LRU cache of minimal coset representatives
    - ``_structure_cache`` -- Cache of cup product geometric structures

    INPUT:

    - ``W`` -- A Weyl group (from ``RootSystem(...).ambient_space().weyl_group()``)
    - ``Plist`` -- List of cells from the Milnor fiber poset (all parabolic cosets)
    - ``Delta`` -- Subset of ``Plist`` defining the excluded arrangement (as set or list)
    - ``max_cache_size`` -- (default: 100000) Maximum entries in LRU cache for
      minimal coset representatives. Increase for better speed at cost of memory.

    EXAMPLES:

    Creating the DGA for the 3-equal arrangement in type A_3::

        sage: W, Plist, _ = build_W_P('A', 3)
        sage: Delta = ideal_k_parabolic(W, Plist, k=3)
        sage: dga = ParabolicArrangementCohomology(W, Plist, Delta)
        sage: print(f"Complex has {len(dga.cells)} cells")
        sage: print(f"Graded dimensions: {[(k, len(cells)) for k, cells in dga.by_grade.items()]}")

    Computing cohomology::

        sage: H0 = dga.cohomology_basis(0, ring=QQ)
        sage: H1 = dga.cohomology_basis(1, ring=QQ)
        sage: print(f"H^0 dimension: {len(H0)}, H^1 dimension: {len(H1)}")

    Computing cup products::

        sage: # Get basis elements
        sage: basis_1 = dga.cohomology_basis(1, ring=GF(2))
        sage: if len(basis_1) >= 2:
        ....:     u, v = basis_1[0], basis_1[1]
        ....:     product = dga.fast_cup_product(u, v, 1, 1, ring=GF(2))
        ....:     print(f"u ∪ v = {product}")

    ALGORITHM:

    The constructor performs the following steps:

    1. **Canonicalize exclusion set**: Convert ``Delta`` to canonical form
    2. **Filter valid cells**: Keep cells from ``Plist`` not in ``Delta``
    3. **Index by degree**: Organize cells by `|J|` for fast degree-wise access
    4. **Build lookup tables**: Create bidirectional cell ↔ index maps

    All cells are stored in canonical form where:
      - `J` is sorted (as tuple)
      - `w` is the minimal-length representative in coset `wW_J`

    This canonicalization ensures that equivalent cells have identical
    representations, enabling O(1) set membership tests and dictionary lookups.

    COMPLEXITY:

    - Time: O(|Plist| \cdot (n \log n + L)) where n = rank, L = average Weyl element length
    - Space: O(|cells| \cdot n)

    The bottleneck is canonicalization of each cell, which requires computing
    the minimal coset representative (greedy descent, O(L \cdot |J|) per cell).
    """

    def __init__(self, W, Plist, Delta, max_cache_size=100000):
        r"""
        Initialize the parabolic zonotopal DGA.

        INPUT:

        - ``W`` -- Weyl group
        - ``Plist`` -- List of all parabolic cosets from Milnor fiber poset
        - ``Delta`` -- Excluded cells (defining the arrangement)
        - ``max_cache_size`` -- (default: 100000) LRU cache size for minimal reps

        TESTS::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: len(dga.cells) > 0
            True
            sage: dga.max_grade == 2  # rank of A_2
            True
        """
        self.W = W
        self._max_cache_size = max_cache_size

        # Cache simple reflections (used extensively throughout)
        self._sref = self.W.simple_reflections()
        self.S = sorted(self._sref.keys())

        # Initialize caches (fresh for each DGA instance)
        self._w0_cache = {}  # longest elements w_{0,J}
        self._structure_cache = OrderedDict()  # LRU-style structure cache
        self._max_structure_cache_size = 50  # Keep only recent structures
        self._min_cache = OrderedDict()  # Manual LRU cache for minimization
        self._max_cache_size = max_cache_size

        # IMPORTANT: Each DGA instance has its own caches to avoid
        # mixing Weyl group elements from different instances

        # Step 1: Canonicalize exclusion set
        delta_clean = set()
        if Delta:
            for c in Delta:
                if self._is_valid_cell(c):
                    delta_clean.add(self._canonize(c))

        # Step 2: Filter and canonicalize cells from Plist
        self.cells = []
        seen = set()

        for c in Plist:
            if not self._is_valid_cell(c):
                continue

            canon_c = self._canonize(c)

            # Skip if in exclusion set or already seen
            if canon_c in delta_clean or canon_c in seen:
                continue

            self.cells.append(canon_c)
            seen.add(canon_c)

        # Step 3: Index cells by grading (degree k = |J|)
        self.by_grade = {}
        self.map_cell_to_idx = {}

        for c in self.cells:
            k = len(c[1])  # dimension = |J|
            self.by_grade.setdefault(k, []).append(c)

        # Step 4: Sort for reproducibility and build index
        # Sorting ensures deterministic behavior across runs
        for k in self.by_grade:
            # Sort by: (string rep of w, then J lexicographically)
            # This is stable and reproducible across Sage sessions
            self.by_grade[k].sort(key=lambda x: (str(x[0]), x[1]))

            for idx, c in enumerate(self.by_grade[k]):
                self.map_cell_to_idx[(k, c)] = idx

        self.max_grade = max(self.by_grade.keys()) if self.by_grade else 0

    # --------------------------------------------------------------------------
    # Utility Methods
    # --------------------------------------------------------------------------

    @staticmethod
    def _is_valid_cell(c):
        r"""
        Check if `c` is a valid cell (tuple of form `(w, J)` where `J` is tuple).

        INPUT:

        - ``c`` -- Candidate cell

        OUTPUT: Boolean

        TESTS::

            sage: from parabolic_arrangement_cohomology import ParabolicArrangementCohomology
            sage: ParabolicArrangementCohomology._is_valid_cell((None, (1,2)))
            True
            sage: ParabolicArrangementCohomology._is_valid_cell("invalid")
            False
        """
        return (isinstance(c, tuple) and
                len(c) == 2 and
                isinstance(c[1], (tuple, list)))

    @staticmethod
    def _is_char2(ring):
        r"""
        Robust test for characteristic 2 rings.

        Works for finite fields, polynomial rings, quotients, etc.

        INPUT:

        - ``ring`` -- A Sage ring

        OUTPUT: Boolean indicating if characteristic is 2

        EXAMPLES::

            sage: from parabolic_arrangement_cohomology import ParabolicArrangementCohomology
            sage: ParabolicArrangementCohomology._is_char2(GF(2))
            True
            sage: ParabolicArrangementCohomology._is_char2(GF(3))
            False
            sage: ParabolicArrangementCohomology._is_char2(ZZ)
            False
            sage: ParabolicArrangementCohomology._is_char2(QQ)
            False
        """
        try:
            return ring.characteristic() == 2
        except (AttributeError, NotImplementedError):
            return False

    @staticmethod
    def _as_vector(ring, x):
        r"""
        Coerce `x` to a Sage vector over `ring`.

        If `x` is already a vector, return as-is. Otherwise convert from
        list/tuple/iterable.

        INPUT:

        - ``ring`` -- Coefficient ring
        - ``x`` -- List, tuple, or vector

        OUTPUT: Sage vector over ``ring``

        EXAMPLES::

            sage: from parabolic_arrangement_cohomology import ParabolicArrangementCohomology
            sage: v = ParabolicArrangementCohomology._as_vector(GF(2), [1, 0, 1])
            sage: v.parent()
            Vector space of dimension 3 over Finite Field of size 2
        """
        if hasattr(x, "parent"):
            return x
        return SageVector(ring, x)

    def clear_caches(self):
        r"""
        Clear all internal caches to free memory.

        Useful when working with very large arrangements or batch processing
        multiple DGAs. Call this between computations if memory is constrained.

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 3)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: dga.coboundary_matrix(1, ring=GF(2))  # Populates caches
            24 x 14 dense matrix over Finite Field of size 2...
            sage: dga.clear_caches()  # Free memory
        """
        self._w0_cache.clear()
        self._structure_cache.clear()
        self._min_cache.clear()

    def cache_info(self):
        r"""
        Return cache statistics (hits, misses, size).

        Useful for performance debugging.

        OUTPUT: Dictionary with cache statistics

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: dga.coboundary_matrix(1, ring=GF(2))
            ...
            sage: info = dga.cache_info()
            sage: 'minimize_size' in info
            True
        """
        return {
            'minimize_size': len(self._min_cache),
            'minimize_maxsize': self._max_cache_size,
            'w0_cache_size': len(self._w0_cache),
            'structure_cache_size': len(self._structure_cache)
        }

    # --------------------------------------------------------------------------
    # Coxeter Group Computations
    # --------------------------------------------------------------------------

    def _canonize(self, c):
        r"""
        Return canonical form of cell `c = (w, J)`.

        Canonical form:
          - `J` sorted lexicographically (as tuple)
          - `w` replaced by minimal-length coset representative in `wW_J`

        INPUT:

        - ``c`` -- Cell (w, J) where w is Weyl group element, J is subset of S

        OUTPUT: Canonical cell `(w_min, J_sorted)`

        ALGORITHM:

        Uses greedy descent: repeatedly right-multiply by simple reflections
        in `J` that decrease length, until no further reduction is possible.

        COMPLEXITY: O(|J| \cdot L) where L is Coxeter length of w

        TESTS::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: w = W.an_element()
            sage: c1 = (w, [2, 1])
            sage: c2 = (w, [1, 2])
            sage: dga._canonize(c1) == dga._canonize(c2)
            True
        """
        w, J = c
        J_tuple = tuple(sorted(J))
        w_min = self._minimize_in_coset(w, J_tuple)
        return (w_min, J_tuple)

    def _minimize_in_coset(self, w, J_tuple):
        r"""
        Compute minimal-length representative in coset `wW_J` with manual LRU cache.

        INPUT:

        - ``w`` -- Weyl group element
        - ``J_tuple`` -- Sorted tuple of simple reflection indices

        OUTPUT: Minimal-length element in `wW_J`

        ALGORITHM:

        Greedy descent: For each `s \in J`, if `ws` has shorter length than `w`,
        replace `w` with `ws`. Repeat until no improvement is possible.

        This is guaranteed to terminate at the unique minimal coset representative
        due to the strong exchange property in Coxeter groups.

        Uses a manual LRU cache with bounded size for performance.

        COMPLEXITY: O(|J| \cdot L) where L = length(w), amortized O(1) with cache

        REFERENCES:

        - [Humphreys] J. Humphreys, "Reflection Groups and Coxeter Groups",
          Cambridge University Press, 1990. Chapter 5.
        """
        key = (w, J_tuple)

        # Check cache
        if key in self._min_cache:
            # Move to end (most recently used)
            self._min_cache.move_to_end(key)
            return self._min_cache[key]

        # Compute minimization
        current = w
        changed = True

        while changed:
            changed = False
            for s_idx in J_tuple:
                s = self._sref[s_idx]
                candidate = current * s

                if candidate.length() < current.length():
                    current = candidate
                    changed = True

        # Store in cache with LRU eviction
        if len(self._min_cache) >= self._max_cache_size:
            # Remove oldest (first) entry
            self._min_cache.popitem(last=False)

        self._min_cache[key] = current
        return current

    def _get_w0_J(self, J_tuple):
        r"""
        Return longest element `w_{0,J}` in parabolic subgroup `W_J`.

        The longest element is unique and characterized by:
          - `\ell(w_{0,J}) = \binom{|J|+1}{2}` (for type A)
          - `w_{0,J}^2 = e` (involution)

        Results are cached since each `W_J` has a unique longest element.

        INPUT:

        - ``J_tuple`` -- Sorted tuple of simple reflection indices

        OUTPUT: Longest element in `W_J` (as element of ambient group `W`)

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 3)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: w0_full = dga._get_w0_J(tuple(dga.S))
            sage: w0_full == W.long_element()
            True
            sage: w0_empty = dga._get_w0_J(())
            sage: w0_empty == W.one()
            True
        """
        if J_tuple in self._w0_cache:
            return self._w0_cache[J_tuple]

        if not J_tuple:
            # Empty parabolic: longest element is identity
            res = self.W.one()
        else:
            try:
                # Try direct method (faster if available)
                res = self.W.long_element(list(J_tuple))
            except (AttributeError, TypeError):
                # Fallback: construct subgroup explicitly
                sub = self.W.reflection_subgroup(list(J_tuple))
                res = self.W(sub.long_element())

        self._w0_cache[J_tuple] = res
        return res

    # --------------------------------------------------------------------------
    # Differential (Coboundary Operator)
    # --------------------------------------------------------------------------

    def coboundary_matrix(self, k, ring=ZZ):
        r"""
        Coboundary matrix `\delta^k: C^k(M, R) \to C^{k+1}(M, R)`.

        The coboundary of a cell `(w, J)` is the signed sum of its faces
        `(w, J \cup \{s\})` for each simple reflection `s \notin J`:

        .. MATH::

            \delta(w, J) = \sum_{s \in S \setminus J} (-1)^{\mathrm{pos}(s, J \cup \{s\})} (w, J \cup \{s\})

        where `\mathrm{pos}(s, K)` is the index of `s` in the sorted list `K`.

        INPUT:

        - ``k`` -- Degree (non-negative integer)
        - ``ring`` -- (default: ``ZZ``) Coefficient ring

        OUTPUT:

        Matrix over ``ring`` of size `\dim C^{k+1} \times \dim C^k`

        ALGORITHM:

        For each cell `(w, J)` in degree `k`:
          1. Enumerate possible new faces `(w, J \cup \{s\})`
          2. Canonicalize each face
          3. Look up index in degree `k+1` cells
          4. Compute sign from position of `s` in `J \cup \{s\}`
          5. Increment matrix entry

        COMPLEXITY: O(|C^k| \cdot |S| \cdot T_{\min}) where T_{\min} is cost
        of minimization (amortized O(1) due to caching).

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: d0 = dga.coboundary_matrix(0, ring=GF(2))
            sage: d1 = dga.coboundary_matrix(1, ring=GF(2))
            sage: (d1 * d0).is_zero()  # δ² = 0
            True

        TESTS::

            sage: # Test d² = 0 in various degrees and rings
            sage: W, Plist, _ = build_W_P('A', 3)
            sage: Delta = ideal_k_parabolic(W, Plist, k=3)
            sage: dga = ParabolicArrangementCohomology(W, Plist, Delta)
            sage: for ring in [GF(2), GF(3), QQ]:
            ....:     for k in range(dga.max_grade):
            ....:         d_k = dga.coboundary_matrix(k, ring=ring)
            ....:         d_k1 = dga.coboundary_matrix(k+1, ring=ring)
            ....:         assert (d_k1 * d_k).is_zero(), f"d^2 != 0 at degree {k} over {ring}"
        """
        # Get cells at degrees k and k+1
        dom = self.by_grade.get(k, [])
        cod = self.by_grade.get(k + 1, [])
        n_dom, n_cod = len(dom), len(cod)

        # Handle trivial cases
        if n_dom == 0 or n_cod == 0:
            return SageMatrix(ring, n_cod, n_dom)

        # Initialize matrix
        M = SageMatrix(ring, n_cod, n_dom)

        # Build reverse lookup for codomain cells
        cod_map = {c: i for i, c in enumerate(cod)}

        # Check if we're in characteristic 2 (no signs needed)
        char2 = self._is_char2(ring)

        # Compute coboundary for each cell in degree k
        for j, (w, J) in enumerate(dom):
            J_set = set(J)

            # Try adding each simple reflection not in J
            for s_idx in self.S:
                if s_idx in J_set:
                    continue

                # Form new face
                J_new = tuple(sorted(J_set | {s_idx}))
                w_new = self._minimize_in_coset(w, J_new)
                c_new = (w_new, J_new)

                # Find index in codomain
                row_idx = cod_map.get(c_new)
                if row_idx is None:
                    # Face not in complex (boundary condition)
                    continue

                # Compute sign: (-1)^{position of s in J_new}
                pos = J_new.index(s_idx)
                sign = 1 if (pos % 2 == 0 or char2) else -1

                M[row_idx, j] += sign

        return M

    # --------------------------------------------------------------------------
    # Cup Product (Zonotopal Diagonal)
    # --------------------------------------------------------------------------

    def precompute_cup_structure(self, dim_u, dim_v, verbose=False):
        r"""
        Precompute geometric structure for cup product at degrees (dim_u, dim_v).

        The cup product depends only on the combinatorial geometry of cells,
        not on the actual cochain values. We precompute the incidence data
        once and reuse it for all cup products at these degrees.

        INPUT:

        - ``dim_u`` -- Degree of first factor
        - ``dim_v`` -- Degree of second factor
        - ``verbose`` -- (default: False) Print progress information

        OUTPUT:

        List of tuples `(idx_target, idx_front, idx_back, sign)` where:
          - ``idx_target``: index of cell in degree `dim_u + dim_v`
          - ``idx_front``: index of front face in degree `dim_u`
          - ``idx_back``: index of back face in degree `dim_v`
          - ``sign``: Koszul sign `\varepsilon(J, K)` from shuffle

        The structure is cached internally for reuse.

        ALGORITHM:

        For each cell `(w, I)` in degree `dim_u + dim_v`:
          1. Enumerate all partitions `I = J \sqcup K` with `|J| = dim_u, |K| = dim_v`
          2. For each partition:
             a. Compute front face `(w, J)` (minimize in coset)
             b. Compute back face `(w \cdot w_{0,J}, K)` (shift by longest element)
             c. Check if both faces exist in the complex
             d. Compute shuffle sign `\varepsilon(J, K)`
             e. Record tuple `(idx_target, idx_front, idx_back, sign)`

        COMPLEXITY: O(|C^{dim_u + dim_v}| \cdot \binom{dim_u + dim_v}{dim_u})

        For large arrangements, this is the computational bottleneck. However,
        it only needs to be done once per (dim_u, dim_v) pair.

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: structure = dga.precompute_cup_structure(1, 1, verbose=True)
            --- Precomputing geometry for Cup(1, 1) ---
            --- Geometry ready. ... connections. ---
            sage: len(structure) > 0
            True
            sage: all(len(entry) == 4 for entry in structure)
            True
        """
        dim_tot = dim_u + dim_v
        key = (dim_u, dim_v)

        # Check cache
        if key in self._structure_cache:
            return self._structure_cache[key]

        if verbose:
            print(f"--- Precomputing geometry for Cup({dim_u}, {dim_v}) ---")

        cells_tot = self.by_grade.get(dim_tot, [])
        structure = []

        # Enumerate all target cells and their subdivisions
        for idx_target, (w, I) in enumerate(cells_tot):
            # Enumerate all ways to partition I into J (size dim_u) and K (size dim_v)
            for partition_indices in itertools.combinations(range(len(I)), dim_u):
                partition_set = set(partition_indices)
                J_list, K_list = [], []
                shuffle_inversions = 0
                k_count = 0

                # Split I into J and K, counting inversions for sign
                for pos in range(len(I)):
                    element = I[pos]
                    if pos in partition_set:
                        J_list.append(element)
                        shuffle_inversions += k_count
                    else:
                        K_list.append(element)
                        k_count += 1

                J = tuple(J_list)
                K = tuple(K_list)

                # Compute front face: (w, J)
                w_front = self._minimize_in_coset(w, J)
                idx_front = self.map_cell_to_idx.get((dim_u, (w_front, J)))
                if idx_front is None:
                    continue

                # Compute back face: (w * w_{0,J}, K)
                w0_J = self._get_w0_J(J)
                w_shifted = w * w0_J
                w_back = self._minimize_in_coset(w_shifted, K)
                idx_back = self.map_cell_to_idx.get((dim_v, (w_back, K)))
                if idx_back is None:
                    continue

                # Koszul sign from shuffle
                sign = -1 if (shuffle_inversions % 2 == 1) else 1

                structure.append((idx_target, idx_front, idx_back, sign))

        # Cache with LRU eviction if too many structures stored
        if len(self._structure_cache) >= self._max_structure_cache_size:
            # Remove oldest entry (first in OrderedDict)
            self._structure_cache.popitem(last=False)

        self._structure_cache[key] = structure

        if verbose:
            print(f"--- Geometry ready. {len(structure)} connections. ---")

        return structure

    def fast_cup_product(self, u, v, dim_u, dim_v, ring=GF(2)):
        r"""
        Fast cup product using precomputed geometric structure.

        Computes `u \cup v` where `u \in C^{dim_u}` and `v \in C^{dim_v}`.

        This is significantly faster than :meth:`cup_product` because it
        avoids recomputing Coxeter minimizations in the inner loop.

        INPUT:

        - ``u`` -- Cochain in degree ``dim_u`` (vector or list)
        - ``v`` -- Cochain in degree ``dim_v`` (vector or list)
        - ``dim_u`` -- Degree of ``u``
        - ``dim_v`` -- Degree of ``v``
        - ``ring`` -- (default: ``GF(2)``) Coefficient ring

        OUTPUT:

        Vector over ``ring`` representing `u \cup v \in C^{dim_u + dim_v}`

        ALGORITHM:

        1. Precompute structure for (dim_u, dim_v) if not cached
        2. Initialize result vector
        3. For each structure entry (idx_target, idx_front, idx_back, sign):
           - Compute term = u[idx_front] * v[idx_back] * sign
           - Add term to result[idx_target]

        COMPLEXITY: O(|structure|) where |structure| ≤ |C^{dim_u+dim_v}| * C(dim_u+dim_v, dim_u)

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: basis1 = dga.cohomology_basis(1, ring=GF(2))
            sage: if len(basis1) >= 2:
            ....:     u, v = basis1[0], basis1[1]
            ....:     product = dga.fast_cup_product(u, v, 1, 1, ring=GF(2))
            ....:     print(f"Product has {product.nonzero_positions()} nonzero entries")

        SEE ALSO:

        - :meth:`cup_product` -- Direct computation (slower but self-contained)
        - :meth:`precompute_cup_structure` -- Structure precomputation
        """
        u = self._as_vector(ring, u)
        v = self._as_vector(ring, v)

        # Get precomputed structure
        structure = self.precompute_cup_structure(dim_u, dim_v, verbose=False)

        # Initialize result
        dim_tot = dim_u + dim_v
        n_tot = len(self.by_grade.get(dim_tot, []))
        res = SageVector(ring, n_tot)

        char2 = self._is_char2(ring)

        # Evaluate using structure
        for (idx_target, idx_front, idx_back, sgn) in structure:
            val_u = u[idx_front]
            if val_u == 0:
                continue

            val_v = v[idx_back]
            if val_v == 0:
                continue

            term = val_u * val_v

            if char2 or sgn == 1:
                res[idx_target] += term
            else:
                res[idx_target] -= term

        return res

    def cup_product(self, u, v, deg_u, deg_v, ring=ZZ):
        r"""
        Cup product via zonotopal diagonal (direct computation).

        Computes `u \cup v` where `u \in C^{deg_u}` and `v \in C^{deg_v}` using
        the zonotopal diagonal approximation:

        .. MATH::

            (u \cup v)(w, I) = \sum_{I = J \sqcup K, |J|=deg_u, |K|=deg_v}
                               \varepsilon(J,K) \cdot u(w,J) \cdot v(w \cdot w_{0,J}, K)

        This method computes the product directly without precomputation. For
        repeated products at the same degrees, use :meth:`fast_cup_product`.

        INPUT:

        - ``u`` -- Cochain in degree ``deg_u``
        - ``v`` -- Cochain in degree ``deg_v``
        - ``deg_u`` -- Degree of ``u``
        - ``deg_v`` -- Degree of ``v``
        - ``ring`` -- (default: ``ZZ``) Coefficient ring

        OUTPUT: Vector representing `u \cup v \in C^{deg_u + deg_v}`

        COMPLEXITY: O(|C^{deg_u + deg_v}| \cdot C(deg_u + deg_v, deg_u) \cdot T_{\min})

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: u = vector(QQ, [1 if i == 0 else 0 for i in range(len(dga.by_grade[1]))])
            sage: v = u  # Same cochain
            sage: product = dga.cup_product(u, v, 1, 1, ring=QQ)
            sage: product.parent()
            Vector space of dimension ... over Rational Field
        """
        u = self._as_vector(ring, u)
        v = self._as_vector(ring, v)

        deg_tot = deg_u + deg_v
        cells_tot = self.by_grade.get(deg_tot, [])
        n_tot = len(cells_tot)
        res = SageVector(ring, n_tot)

        if n_tot == 0:
            return res

        char2 = self._is_char2(ring)

        # Compute product for each target cell
        for idx_target, (w, I) in enumerate(cells_tot):
            acc = ring.zero() if hasattr(ring, 'zero') else ring(0)

            # Partition I into J (size deg_u) and K (size deg_v)
            for partition_indices in itertools.combinations(range(len(I)), deg_u):
                partition_set = set(partition_indices)
                J_list, K_list = [], []
                shuffle_inversions = 0
                k_count = 0

                for pos in range(len(I)):
                    element = I[pos]
                    if pos in partition_set:
                        J_list.append(element)
                        shuffle_inversions += k_count
                    else:
                        K_list.append(element)
                        k_count += 1

                J = tuple(J_list)
                K = tuple(K_list)

                # Front face
                w_front = self._minimize_in_coset(w, J)
                idx_u = self.map_cell_to_idx.get((deg_u, (w_front, J)))
                if idx_u is None:
                    continue

                val_u = u[idx_u]
                if val_u == 0:
                    continue

                # Back face
                w0_J = self._get_w0_J(J)
                w_shifted = w * w0_J
                w_back = self._minimize_in_coset(w_shifted, K)
                idx_v = self.map_cell_to_idx.get((deg_v, (w_back, K)))
                if idx_v is None:
                    continue

                val_v = v[idx_v]
                if val_v == 0:
                    continue

                # Accumulate with sign
                term = val_u * val_v
                if (not char2) and (shuffle_inversions % 2 == 1):
                    acc -= term
                else:
                    acc += term

            res[idx_target] = acc

        return res

    # --------------------------------------------------------------------------
    # Cohomology Computation
    # --------------------------------------------------------------------------

    def cohomology_basis(self, k, ring=GF(2)):
        r"""
        Compute a basis for `H^k(M, R) = \ker(\delta^k) / \mathrm{im}(\delta^{k-1})`.

        Returns a list of cocycles representing cohomology classes. Each cocycle
        is a vector in `C^k(M, R)`.

        INPUT:

        - ``k`` -- Degree (non-negative integer)
        - ``ring`` -- (default: ``GF(2)``) Coefficient ring (should be a field)

        OUTPUT:

        List of vectors forming a basis for `H^k(M, R)`

        ALGORITHM:

        1. Compute `\delta^{k-1}: C^{k-1} \to C^k` and `\delta^k: C^k \to C^{k+1}`
        2. Find kernel of `\delta^k` (cocycles)
        3. Find image of `\delta^{k-1}` (coboundaries)
        4. Return basis for quotient `\ker(\delta^k) / \mathrm{im}(\delta^{k-1})`

        This uses Sage's vector space quotient machinery, which requires a field.
        Over ZZ or other rings, cohomology may have torsion that this method
        cannot detect.

        COMPLEXITY: O(n^3) where n = max(dim C^{k-1}, dim C^k, dim C^{k+1})
        (dominated by kernel computation and quotient)

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: H0 = dga.cohomology_basis(0, ring=QQ)
            sage: len(H0)  # Should be 1 (connected space)
            1
            sage: H1 = dga.cohomology_basis(1, ring=GF(2))
            sage: len(H1) >= 0
            True

        TESTS::

            sage: # Test that basis vectors are actually cocycles
            sage: W, Plist, _ = build_W_P('A', 3)
            sage: Delta = ideal_k_parabolic(W, Plist, k=3)
            sage: dga = ParabolicArrangementCohomology(W, Plist, Delta)
            sage: for k in range(min(3, dga.max_grade + 1)):
            ....:     basis = dga.cohomology_basis(k, ring=GF(2))
            ....:     d = dga.coboundary_matrix(k, ring=GF(2))
            ....:     for b in basis:
            ....:         assert (d * b).is_zero(), f"Basis element not a cocycle in degree {k}"
        """
        # Handle degree 0 specially (no coboundaries)
        if k == 0:
            n_cells_0 = len(self.by_grade.get(0, []))
            prev_im = SageMatrix(ring, n_cells_0, 0)
        else:
            prev_im = self.coboundary_matrix(k - 1, ring)

        # Get current coboundary map
        curr_map = self.coboundary_matrix(k, ring)

        # Empty complex at this degree
        if curr_map.ncols() == 0:
            return []

        # Compute kernel (cocycles)
        ker_basis_matrix = curr_map.right_kernel().basis_matrix()

        # Ambient space
        V = SageVector(ring, [0] * curr_map.ncols()).parent()

        # Subspaces
        W_ker = V.subspace(ker_basis_matrix.rows()) if ker_basis_matrix.nrows() > 0 else V.zero_subspace()
        W_im = V.subspace(prev_im.columns()) if prev_im.ncols() > 0 else V.zero_subspace()

        # Quotient
        try:
            Q = W_ker.quotient(W_im)
            return [Q.lift(gen) for gen in Q.basis()]
        except (ValueError, AttributeError):
            # Quotient failed (can happen with certain coefficient rings)
            return []

    def cup_product_span_analysis(self, ring=GF(2), max_pairs=None,
                                  prefer_small_support=True, verbose=True):
        r"""
        **VALIDATION METHOD**: Verify Baryshnikov's generation theorem for `H^2`.

        This method verifies that `H^2` is generated by cup products of classes
        in `H^1` by progressively computing cup products `u_i \cup u_j` for pairs
        of generators `u_i, u_j \in H^1` and checking if they span `H^2`.

        This is a validation of Baryshnikov's result for k-equal arrangements,
        adapted to the parabolic setting. See León-Medina & Cantarero for the
        general theory.

        INPUT:

        - ``ring`` -- (default: ``GF(2)``) Coefficient ring
        - ``max_pairs`` -- (default: None) Maximum number of pairs to test
          (None = test all `\binom{dim H^1}{2}` pairs)
        - ``prefer_small_support`` -- (default: True) Order basis elements by
          Hamming weight to find generators faster
        - ``verbose`` -- (default: True) Print progress information

        OUTPUT:

        Dictionary with keys:
          - ``'rank_generated'``: Rank of the subspace generated by cup products
          - ``'dim_H2'``: Dimension of `H^2`
          - ``'generating_pairs'``: List of pairs `(i, j)` that contribute new dimensions
          - ``'is_complete'``: Boolean indicating if `H^2` is fully generated
          - ``'time'``: Time elapsed in seconds

        ALGORITHM:

        1. Compute bases for `H^1` and `H^2`
        2. Precompute cup product structure (done once, cached)
        3. Build projection matrix `[H^2 \, | \, \mathrm{im}(\delta^1)]`
        4. For each pair `(i < j)`:
           a. Compute `u_i \cup u_j` using fast cup product
           b. Project to `H^2` via `\mathrm{solve\_right}`
           c. Check if coordinates increase span rank
           d. Stop early when rank reaches `\dim(H^2)`

        COMPLEXITY:

        - Precomputation: `O(n^2)` where `n = |C^2|`
        - Per product: `O(|C^2|)` for cup + `O(d^2)` for projection where `d = \dim(H^2)`
        - Total: `O(p \cdot |C^2|)` where `p` is number of pairs tested

        EXAMPLES::

            sage: # Verify H^2 generation for A_5 (k=3)
            sage: W, Plist, _ = build_W_P('A', 5)
            sage: Delta = ideal_k_parabolic(W, Plist, k=3)
            sage: dga = ParabolicArrangementCohomology(W, Plist, Delta)
            sage: result = dga.cup_product_span_analysis(ring=GF(2))
            Precomputing cup structure for (1,1)...
            --- Precomputing geometry for Cup(1, 1) ---
            --- Geometry ready. 2160 connections. ---
            Building projection matrix...
            Analyzing 6105 pairs...
            [Hit #1] Pair (10, 2) -> Rank 1/20
            ...
            [Hit #20] Pair (109, 78) -> Rank 20/20
            SUCCESS: H^2 fully generated in 5.2s
            sage: result['is_complete']
            True
            sage: result['rank_generated']
            20
            sage: len(result['generating_pairs'])
            20

        TESTS::

            sage: # Test with A_3 (H^2 = 0)
            sage: W, Plist, _ = build_W_P('A', 3)
            sage: Delta = ideal_k_parabolic(W, Plist, k=3)
            sage: dga = ParabolicArrangementCohomology(W, Plist, Delta)
            sage: result = dga.cup_product_span_analysis(verbose=False)
            sage: result['dim_H2']
            0
            sage: result['is_complete']
            True

        REFERENCES:

        - J.-L. León-Medina and J. Cantarero, "The Topology of Real Parabolic
          Arrangements", manuscript in preparation.

        .. NOTE::

            Early termination occurs when the span reaches `\dim(H^2)`.
        """
        import time

        if verbose:
            print("=" * 60)
            print("CUP PRODUCT SPAN ANALYSIS")
            print("=" * 60)

        t_start = time.time()

        # Compute cohomology bases
        if verbose:
            print("\nComputing cohomology bases...")

        H1 = self.cohomology_basis(1, ring)
        H2 = self.cohomology_basis(2, ring)

        dim_H1 = len(H1)
        dim_H2 = len(H2)

        if verbose:
            print(f"  dim(H^1) = {dim_H1}")
            print(f"  dim(H^2) = {dim_H2}")

        # Trivial cases
        if dim_H2 == 0:
            if verbose:
                print("\nH^2 = 0, trivially complete.")
            return {
                'rank_generated': 0,
                'dim_H2': 0,
                'generating_pairs': [],
                'is_complete': True,
                'time': time.time() - t_start
            }

        if dim_H1 < 2:
            if verbose:
                print(f"\ndim(H^1) = {dim_H1} < 2, cannot form products.")
            return {
                'rank_generated': 0,
                'dim_H2': dim_H2,
                'generating_pairs': [],
                'is_complete': False,
                'time': time.time() - t_start
            }

        # Precompute cup product structure
        if verbose:
            print("\nPrecomputing cup structure for (1,1)...")
        self.precompute_cup_structure(1, 1, verbose=verbose)

        # Build projection matrix [H^2 | im(delta^1)]
        if verbose:
            print("Building projection matrix...")

        n_C2 = len(self.by_grade.get(2, []))

        # Matrix whose columns are H^2 basis vectors
        M_H2 = SageMatrix(ring, n_C2, dim_H2)
        for col_idx, vec in enumerate(H2):
            M_H2.set_column(col_idx, list(vec))

        # Coboundary matrix delta^1: C^1 -> C^2
        M_d1 = self.coboundary_matrix(1, ring)

        # Projection matrix: solving [M_H2 | M_d1] * x = prod gives coords in H^2
        Proj_Matrix = M_H2.augment(M_d1)

        # Progressive span search
        total_pairs = dim_H1 * (dim_H1 - 1) // 2
        if max_pairs is not None:
            total_pairs = min(total_pairs, max_pairs)

        if verbose:
            print(f"\nAnalyzing {total_pairs} pairs...")

        # Order indices by support size if requested
        if prefer_small_support:
            H1_indices = sorted(range(dim_H1), key=lambda i: H1[i].hamming_weight())
        else:
            H1_indices = list(range(dim_H1))

        # Track span
        Found_Space = SageMatrix(ring, dim_H2, 0)
        rank_found = 0
        generating_pairs = []

        pairs_tested = 0

        for i_idx in range(dim_H1):
            for j_idx in range(i_idx + 1, dim_H1):
                # Early termination
                if rank_found == dim_H2:
                    break

                if pairs_tested >= total_pairs:
                    break

                pairs_tested += 1

                real_i = H1_indices[i_idx]
                real_j = H1_indices[j_idx]

                u = H1[real_i]
                v = H1[real_j]

                # Compute cup product
                prod = self.fast_cup_product(u, v, 1, 1, ring)

                if prod.is_zero():
                    continue

                # Project to H^2
                try:
                    sol = Proj_Matrix.solve_right(prod)
                    coords = sol[:dim_H2]
                except (ValueError, ArithmeticError):
                    # Product is not in ker(delta^2), shouldn't happen
                    continue

                if coords.is_zero():
                    continue

                # Check if increases rank
                M_test = Found_Space.augment(SageMatrix(ring, dim_H2, 1, list(coords)))
                new_rank = M_test.rank()

                if new_rank > rank_found:
                    rank_found = new_rank
                    Found_Space = M_test
                    generating_pairs.append((real_i, real_j))

                    if verbose:
                        print(f"[Hit #{len(generating_pairs)}] Pair ({real_i}, {real_j}) -> Rank {rank_found}/{dim_H2}")

            if rank_found == dim_H2:
                break

        t_elapsed = time.time() - t_start
        is_complete = (rank_found == dim_H2)

        if verbose:
            print("\n" + "=" * 60)
            if is_complete:
                print(f"SUCCESS: H^2 fully generated in {t_elapsed:.1f}s")
            else:
                print(f"INCOMPLETE: Only {rank_found}/{dim_H2} dimensions generated in {t_elapsed:.1f}s")
            print("=" * 60)

        return {
            'rank_generated': rank_found,
            'dim_H2': dim_H2,
            'generating_pairs': generating_pairs,
            'is_complete': is_complete,
            'time': t_elapsed
        }

    # --------------------------------------------------------------------------
    # DGA Structure Verification
    # --------------------------------------------------------------------------

    def verify_leibniz_rule(self, ring=GF(2), trials=20, use_fast=False, max_degree=None):
        r"""
        Verify the graded Leibniz (product) rule for the DGA structure.

        The Leibniz rule states:

        .. MATH::

            \delta(u \cup v) = (\delta u) \cup v + (-1)^{|u|} u \cup (\delta v)

        This is tested probabilistically by generating random cochains and
        checking the identity.

        INPUT:

        - ``ring`` -- (default: ``GF(2)``) Coefficient ring for testing
        - ``trials`` -- (default: 20) Number of random tests per degree pair
        - ``use_fast`` -- (default: False) Use :meth:`fast_cup_product` if True
        - ``max_degree`` -- (default: None) Maximum degree to test (None = all)

        OUTPUT:

        Boolean: True if all tests pass, False if any violation is detected

        EXAMPLES::

            sage: W, Plist, _ = build_W_P('A', 2)
            sage: dga = ParabolicArrangementCohomology(W, Plist, set())
            sage: dga.verify_leibniz_rule(ring=GF(2), trials=10, use_fast=True)
            --- Verifying DGA Leibniz Rule over Finite Field of size 2 ---
            Testing degrees (1, 1)...
            Leibniz Rule Verified: The DGA structure is consistent.
            True

        TESTS::

            sage: # Test over different rings
            sage: W, Plist, _ = build_W_P('A', 3)
            sage: Delta = ideal_k_parabolic(W, Plist, k=3)
            sage: dga = ParabolicArrangementCohomology(W, Plist, Delta)
            sage: dga.verify_leibniz_rule(ring=GF(2), trials=5)
            ...
            True
            sage: dga.verify_leibniz_rule(ring=GF(3), trials=5)
            ...
            True
        """
        print(f"--- Verifying DGA Leibniz Rule over {ring} ---")

        char2 = self._is_char2(ring)
        prod = self.fast_cup_product if use_fast else self.cup_product

        # Determine degrees to test
        if max_degree is None:
            max_degree = min(self.max_grade, 3)  # Default: test up to degree 3

        test_degrees = [(p, q) for p in range(1, max_degree)
                        for q in range(1, max_degree)
                        if p + q <= self.max_grade]

        if not test_degrees:
            print("No degree pairs to test (complex too small)")
            return True

        # Test each degree pair
        for (deg_u, deg_v) in test_degrees:
            print(f"Testing degrees ({deg_u}, {deg_v})...")

            # Get coboundary matrices
            d_u = self.coboundary_matrix(deg_u, ring)
            d_v = self.coboundary_matrix(deg_v, ring)
            d_sum = self.coboundary_matrix(deg_u + deg_v, ring)

            n_u = d_u.ncols()
            n_v = d_v.ncols()

            if n_u == 0 or n_v == 0:
                continue

            # Run random trials
            for trial in range(trials):
                # Generate random cochains
                u = SageVector(ring, [ring.random_element() for _ in range(n_u)])
                v = SageVector(ring, [ring.random_element() for _ in range(n_v)])

                # LHS: δ(u ∪ v)
                uv = prod(u, v, deg_u, deg_v, ring)
                lhs = d_sum * uv

                # RHS: (δu) ∪ v + (-1)^|u| u ∪ (δv)
                du = d_u * u
                dv = d_v * v

                term1 = prod(du, v, deg_u + 1, deg_v, ring)
                term2 = prod(u, dv, deg_u, deg_v + 1, ring)

                if char2:
                    rhs = term1 + term2
                else:
                    # Koszul sign: (-1)^{deg_u}
                    if deg_u % 2 == 0:
                        rhs = term1 + term2
                    else:
                        rhs = term1 - term2

                # Check equality
                if lhs != rhs:
                    print(f"[FAIL] Leibniz rule violation at degrees ({deg_u}, {deg_v}), trial {trial}")
                    print(f"  LHS (δ(u∪v)): {lhs}")
                    print(f"  RHS: {rhs}")
                    return False

        print("Leibniz Rule Verified: The DGA structure is consistent.")
        return True


# ==============================================================================
# Construction Helpers
# ==============================================================================

def build_W_P(weyl_type, weyl_rank):
    r"""
    Construct Weyl group and Milnor fiber poset for a given type and rank.

    The Milnor fiber poset `P` consists of all parabolic cosets `(w, J)` where
    `w \in W` and `J \subseteq S` (simple reflections), partially ordered by
    reverse inclusion on the `J` components.

    INPUT:

    - ``weyl_type`` -- Cartan type ('A', 'B', 'C', 'D', 'E', 'F', 'G')
    - ``weyl_rank`` -- Rank (positive integer)

    OUTPUT:

    Tuple ``(W, Plist, Pobj)`` where:
      - ``W``: Weyl group (SageMath WeylGroup object)
      - ``Plist``: List of all parabolic cosets (elements of poset)
      - ``Pobj``: Poset object (SageMath Poset)

    EXAMPLES::

        sage: W, Plist, Pobj = build_W_P('A', 2)
        sage: W.cartan_type()
        ['A', 2]
        sage: len(Plist) > 0
        True
        sage: Pobj.is_graded()
        True

    TESTS::

        sage: # Test various Weyl groups
        sage: for typ in ['A', 'B', 'D']:
        ....:     W, Plist, _ = build_W_P(typ, 2)
        ....:     assert len(Plist) > 0, f"Empty poset for type {typ}_2"
    """
    W = RootSystem([weyl_type, Integer(weyl_rank)]).ambient_space().weyl_group()
    Pobj = W.milnor_fiber_poset()
    Plist = list(Pobj)
    return W, Plist, Pobj


def ideal_k_parabolic(W, Plist, k=3):
    r"""
    Construct the order ideal defining the k-parabolic arrangement.

    A **k-parabolic arrangement** (also called "k-equal arrangement" in type A)
    excludes all hyperplanes indexed by parabolic subsets `J \subseteq S` that
    contain a connected component of size ≥ k-1 in the Dynkin diagram.

    INPUT:

    - ``W`` -- Weyl group
    - ``Plist`` -- List of parabolic cosets from Milnor fiber poset
    - ``k`` -- (default: 3) Parameter defining the arrangement

    OUTPUT:

    Set of cells to be excluded (defining the removed hyperplanes)

    ALGORITHM:

    For each cell `(w, J)`:
      1. Construct the subgraph of the Dynkin diagram induced by `J`
      2. Compute connected components
      3. If any component has size ≥ k-1, add cell to exclusion set

    EXAMPLES::

        sage: W, Plist, _ = build_W_P('A', 3)
        sage: Delta = ideal_k_parabolic(W, Plist, k=3)
        sage: len(Delta) > 0  # Some cells are excluded
        True
        sage:
        sage: # 3-equal arrangement excludes {i,i+1,i+2} parabolics
        sage: excluded_types = {c[1] for c in Delta if len(c[1]) == 3}
        sage: (1,2,3) in excluded_types  # Consecutive triple excluded
        True

    MATHEMATICAL NOTE:

    In type A_n, the k-parabolic arrangement is the complement of the
    "k-equal" hyperplane arrangement:

    .. MATH::

        \{x_i = x_j : |i - j| < k\}

    For general types, this generalizes using Dynkin diagram connectivity.

    REFERENCES:

    - [BW] E. Babson and V. Welker, "Cellular resolutions of ideals defined
      by simplicial homomorphisms", 2002.
    """
    ct = W.cartan_type()
    dynkin_graph = Graph(ct.dynkin_diagram())

    threshold = k - 1
    Delta = set()

    for c in Plist:
        # Validate cell format
        if not (isinstance(c, tuple) and len(c) == 2 and isinstance(c[1], (tuple, list))):
            continue

        w, J = c

        # Skip small subsets (can't have large components)
        if len(J) < threshold:
            continue

        # Check connected components in Dynkin diagram
        subgraph = dynkin_graph.subgraph(vertices=list(J))
        components = subgraph.connected_components()

        # Exclude if any component is too large
        if any(len(comp) >= threshold for comp in components):
            Delta.add(c)

    return Delta


# Alias for backward compatibility with type A literature
ideal_non_k_equal = ideal_k_parabolic
